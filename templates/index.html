<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>영어 학습 플레이어</title>
    
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1e1e1e;
            color: #cccccc;
            display: flex;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        
        /* VSCode style layout */
        .activity-bar {
            width: 48px;
            background: #333333;
            border-right: 1px solid #444444;
            display: flex;
            flex-direction: column;
            padding: 8px 0;
        }
        
        .activity-item {
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: #888888;
            font-size: 1.2em;
            border: none;
            background: none;
            transition: all 0.2s;
        }
        
        .activity-item:hover {
            background: #444444;
            color: #cccccc;
        }
        
        .activity-item.active {
            background: #0e639c;
            color: #ffffff;
            border-left: 2px solid #ffffff;
        }
        
        /* 단어 클릭 스타일 */
        .interactive-word {
            cursor: pointer;
            border-bottom: 1px dotted rgba(255,255,255,0.2);
            transition: all 0.2s ease;
            padding: 1px 2px;
            border-radius: 2px;
        }
        
        /* 로딩 스피너 */
        .loading-spinner {
            width: 12px;
            height: 12px;
            border: 2px solid #333;
            border-top: 2px solid #4CAF50;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* 단어장 추가 관련 스타일 */
        .vocab-added {
            background: rgba(76, 175, 80, 0.2) !important;
            border: 1px solid #4CAF50 !important;
        }
        
        /* 난이도별 색상 스타일 */
        .difficulty-easy {
            color: #81C784 !important; /* 연한 초록 - 쉬운 단어 */
            border-bottom-color: rgba(129, 199, 132, 0.3) !important;
        }
        
        .difficulty-medium {
            color: #FFB74D !important; /* 주황 - 중간 단어 */
            border-bottom-color: rgba(255, 183, 77, 0.3) !important;
        }
        
        .difficulty-hard {
            color: #F06292 !important; /* 분홍 - 어려운 단어 */
            border-bottom-color: rgba(240, 98, 146, 0.3) !important;
        }
        
        .difficulty-very-hard {
            color: #E57373 !important; /* 빨강 - 매우 어려운 단어 */
            border-bottom-color: rgba(229, 115, 115, 0.3) !important;
            font-weight: 600;
        }
        
        
        /* 문법 패턴 하이라이트 스타일 */
        .grammar-conditional {
            background: linear-gradient(90deg, #2196F3, #21CBF3);
            color: white !important;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(33, 150, 243, 0.3);
        }
        
        .grammar-time {
            background: linear-gradient(90deg, #9C27B0, #E91E63);
            color: white !important;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(156, 39, 176, 0.3);
        }
        
        .grammar-cause {
            background: linear-gradient(90deg, #FF9800, #FF5722);
            color: white !important;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(255, 152, 0, 0.3);
        }
        
        .grammar-contrast {
            background: linear-gradient(90deg, #F44336, #E91E63);
            color: white !important;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(244, 67, 54, 0.3);
        }
        
        .grammar-passive {
            background: linear-gradient(90deg, #607D8B, #455A64);
            color: white !important;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(96, 125, 139, 0.3);
        }
        
        .grammar-perfect {
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            color: white !important;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(76, 175, 80, 0.3);
        }
        
        .grammar-future {
            background: linear-gradient(90deg, #00BCD4, #03A9F4);
            color: white !important;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(0, 188, 212, 0.3);
        }
        
        .grammar-modal {
            background: linear-gradient(90deg, #795548, #5D4037);
            color: white !important;
            padding: 2px 4px;
            border-radius: 3px;
            font-size: 0.9em;
            font-weight: 500;
            box-shadow: 0 1px 3px rgba(121, 85, 72, 0.3);
        }
        
        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
        
        @keyframes slideOutRight {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }
        
        .sidebar {
            width: 300px;
            min-width: 200px;
            max-width: 600px;
            background: #252526;
            border-right: 1px solid #444444;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }
        
        .sidebar.collapsed {
            width: 0;
            min-width: 0;
            border-right: none;
            overflow: hidden;
        }
        
        .sidebar.collapsed .sidebar-content {
            display: none;
        }
        
        .sidebar.collapsed .sidebar-resizer {
            display: none;
        }
        
        .sidebar-resizer {
            position: absolute;
            right: -5px;
            top: 0;
            bottom: 0;
            width: 10px;
            cursor: ew-resize;
            background: rgba(14, 99, 156, 0.1);
            z-index: 1001;
            border-right: 2px solid transparent;
        }
        
        .sidebar-resizer:hover {
            background: rgba(14, 99, 156, 0.3) !important;
            border-right: 2px solid #0e639c !important;
        }
        
        .sidebar-header {
            padding: 10px 15px;
            border-bottom: 1px solid #444444;
            font-size: 0.9em;
            font-weight: bold;
            text-transform: uppercase;
            color: #cccccc;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        .main-content {
            flex: 1;
            background: #1e1e1e;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        
        .right-sidebar {
            width: 400px;
            min-width: 300px;
            max-width: 800px;
            background: #252526;
            border-left: 1px solid #444444;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }
        
        .right-sidebar.collapsed {
            width: 0;
            min-width: 0;
            border-left: none;
        }
        
        .right-sidebar-resizer {
            position: absolute;
            left: -15px;
            top: 0;
            bottom: 0;
            width: 30px;
            cursor: ew-resize;
            background: rgba(14, 99, 156, 0.1);
            z-index: 1001;
            border-left: 2px solid transparent;
            pointer-events: auto;
        }
        
        .right-sidebar-resizer:hover {
            background: rgba(14, 99, 156, 0.7) !important;
            border-left: 3px solid #0e639c !important;
        }
        
        .right-sidebar-header {
            padding: 10px 15px;
            border-bottom: 1px solid #444444;
            font-size: 0.9em;
            font-weight: bold;
            color: #cccccc;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .sidebar-toggle {
            background: none;
            border: none;
            color: #888888;
            cursor: pointer;
            font-size: 16px;
            padding: 4px;
            border-radius: 3px;
            transition: background 0.2s;
        }
        
        .sidebar-toggle:hover {
            background: #444444;
            color: #cccccc;
        }
        
        .right-sidebar-content {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
        }
        
        /* Media player */
        .media-player {
            background: #2d2d30;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
            width: 100%;
            box-sizing: border-box;
        }
        
        audio {
            width: 100%;
            margin-top: 10px;
        }
        
        /* 비디오 반응형 스타일 */
        video#videoPlayer {
            width: 100% !important;
            max-width: 100% !important;
            height: auto !important;
            max-height: 70vh !important;
            object-fit: contain !important;
            background: #000000;
        }
        
        /* 메인 콘텐츠 반응형 */
        .main-content {
            transition: width 0.3s ease;
        }
        
        /* Sentences */
        .chapter-section {
            margin: 20px 0;
            border: 1px solid #444444;
            border-radius: 5px;
            background: #252526;
        }
        
        .chapter-header {
            background: #333333;
            padding: 15px;
            cursor: pointer;
            border-radius: 5px 5px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }
        
        .chapter-header:hover {
            background: #404040;
        }
        
        .chapter-title {
            font-weight: bold;
            color: #cccccc;
        }
        
        .chapter-info {
            font-size: 0.9em;
            color: #858585;
        }
        
        .chapter-content {
            padding: 10px;
        }
        
        .scene-section {
            margin: 15px 0;
            border: 1px solid #555555;
            border-radius: 3px;
            background: #2d2d30;
        }
        
        .scene-header {
            background: #404040;
            padding: 10px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background 0.2s;
        }
        
        .scene-header:hover {
            background: #4a4a4a;
        }
        
        .scene-title {
            font-weight: bold;
            color: #cccccc;
            font-size: 0.9em;
        }
        
        .scene-info {
            font-size: 0.8em;
            color: #858585;
        }
        
        .scene-content {
            padding: 10px;
        }
        
        .sentence-item {
            background: #1e1e1e;
            padding: 12px;
            margin: 8px 0;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
            transition: background 0.2s;
        }
        
        .sentence-item:hover {
            background: #2d2d30;
        }
        
        .sentence-item.bookmarked {
            background: #4e4e2a;
            border-left: 3px solid #ffd700;
        }
        
        .sentence-item.playing {
            background: #2d4a2d;
            border-left: 3px solid #4CAF50;
        }
        
        .collapse-icon {
            font-size: 12px;
            transition: transform 0.2s;
        }
        
        .collapsed .collapse-icon {
            transform: rotate(-90deg);
        }
        
        .sentence-number {
            color: #858585;
            margin-right: 10px;
        }
        
        .sentence-text {
            color: #cccccc;
            line-height: 1.5;
            display: inline;
        }
        
        .sentence-korean {
            color: #858585;
            font-size: 0.9em;
            margin-left: 10px;
            display: inline;
        }
        
        .bookmark-btn {
            position: absolute;
            right: 60px;
            top: 15px;
            background: none;
            border: none;
            color: #858585;
            font-size: 20px;
            cursor: pointer;
        }
        
        .sentence-item.bookmarked .bookmark-btn {
            color: #ffd700;
        }
        
        .extract-btn {
            position: absolute;
            right: 15px;
            top: 15px;
            background: #0e639c;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .extract-btn:hover {
            background: #1177bb;
        }
        
        /* Scene navigation highlight */
        .sentence-item.highlighted {
            background: rgba(14, 99, 156, 0.3);
            border: 2px solid #0e639c;
            animation: pulse 0.5s ease-in-out;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }
        
        .scene-header {
            cursor: pointer;
        }
        
        .scene-title:hover {
            color: #0e639c;
        }
        
        /* Right sidebar panels */
        .extract-panel, .filter-panel, .bookmarked-panel {
            margin-bottom: 25px;
            padding: 15px;
            background: #2d2d30;
            border-radius: 5px;
            border: 1px solid #444444;
        }
        
        .extract-panel h3, .filter-panel h3, .bookmarked-panel h3 {
            margin-bottom: 15px;
            color: #cccccc;
            font-size: 1em;
            border-bottom: 1px solid #444444;
            padding-bottom: 8px;
        }
        
        .extract-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .extract-option-btn {
            background: #0e639c;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
            transition: background 0.2s;
            text-align: left;
        }
        
        .extract-option-btn:hover {
            background: #1177bb;
        }
        
        .extract-option-btn:disabled {
            background: #555555;
            cursor: not-allowed;
        }
        
        .extract-status {
            margin-top: 10px;
            padding: 8px;
            background: #1e1e1e;
            border-radius: 3px;
            font-size: 0.8em;
            color: #858585;
            min-height: 20px;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #333333;
            border-radius: 2px;
            margin: 5px 0;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #0e639c, #1177bb);
            transition: width 0.3s ease;
            width: 0%;
        }
        
        .vad-info {
            font-size: 0.7em !important;
            margin-top: 2px;
            padding: 2px 4px;
            border-radius: 2px;
            display: inline-block;
        }
        
        .filter-options label {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #cccccc;
            cursor: pointer;
        }
        
        .filter-details {
            margin-top: 8px;
            padding: 8px;
            background: #1e1e1e;
            border-radius: 3px;
            color: #858585;
        }
        
        /* Chapter and Scene header extract buttons */
        .chapter-extract-btn, .scene-extract-btn {
            background: #0e639c;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8em;
            margin-left: 10px;
        }
        
        .chapter-extract-btn:hover, .scene-extract-btn:hover {
            background: #1177bb;
        }
        
        /* Controls */
        .controls {
            margin: 20px 0;
        }
        
        .btn {
            background: #0e639c;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 3px;
            cursor: pointer;
            margin-right: 10px;
        }
        
        .btn:hover {
            background: #1177bb;
        }
        
        .btn-export {
            background: #d79921;
        }
        
        .btn-export:hover {
            background: #fabd2f;
        }
        
        /* Upload area */
        .upload-area {
            border: 2px dashed #444444;
            border-radius: 5px;
            padding: 30px;
            text-align: center;
            margin-bottom: 20px;
            transition: border-color 0.3s, background-color 0.3s;
        }
        
        .upload-area.drag-over {
            border-color: #0e639c;
            background: rgba(14, 99, 156, 0.1);
        }
        
        .upload-area input[type="file"] {
            margin-top: 10px;
            width: 100%;
            padding: 10px;
            border: 1px solid #444444;
            background: #2d2d30;
            color: #cccccc;
            border-radius: 3px;
        }
        
        .media-item {
            padding: 8px 30px 8px 8px; /* 오른쪽에 삭제 버튼 공간 확보 */
            margin: 5px 0;
            background: #2d2d30;
            border-radius: 3px;
            cursor: pointer;
            transition: background 0.2s;
            position: relative;
            word-wrap: break-word;
            word-break: break-word;
        }
        
        .media-item:hover {
            background: #37373d;
        }
        
        .media-item.active {
            background: #0e639c;
        }
        
        .chapter-item {
            margin: 5px 0;
            padding: 5px;
            background: #37373d;
            border-radius: 3px;
            font-size: 0.9em;
        }
        
        .scene-item {
            margin: 2px 0 2px 15px;
            padding: 3px;
            background: #2d2d30;
            border-radius: 2px;
            font-size: 0.8em;
            color: #858585;
        }
        
        /* Bookmarked list */
        .bookmarked-panel {
            background: #2d2d30;
            padding: 15px;
            border-radius: 5px;
        }
        
        .bookmarked-panel h3 {
            margin-bottom: 15px;
            color: #cccccc;
        }
        
        .bookmarked-item {
            padding: 8px;
            margin: 5px 0;
            background: #1e1e1e;
            border-radius: 3px;
        }
        
        /* 모달 스타일 */
        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
        }
        
        .modal-content {
            background-color: #2d2d30;
            margin: 10% auto;
            padding: 20px;
            border: 1px solid #444444;
            border-radius: 5px;
            width: 400px;
            max-width: 90%;
            color: #cccccc;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #444444;
            padding-bottom: 10px;
        }
        
        .modal-close {
            color: #858585;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            background: none;
            border: none;
        }
        
        .modal-close:hover {
            color: #cccccc;
        }
        
        .modal-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .modal-form label {
            color: #cccccc;
            font-size: 0.9em;
            margin-bottom: 5px;
        }
        
        .modal-form select, .modal-form input {
            width: 100%;
            padding: 8px;
            border: 1px solid #444444;
            background: #1e1e1e;
            color: #cccccc;
            border-radius: 3px;
            font-size: 0.9em;
        }
        
        .modal-form button {
            width: 100%;
            padding: 12px;
            background: #0e639c;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-top: 10px;
        }
        
        .modal-form button:hover {
            background: #1177bb;
        }
        
        .modal-form button.srt-btn {
            background: #4caf50;
        }
        
        .modal-form button.srt-btn:hover {
            background: #66bb6a;
        }
        
        .extract-option-btn.delete-btn {
            background: #d32f2f;
        }
        
        .extract-option-btn.delete-btn:hover {
            background: #f44336;
        }
    </style>
</head>
<body>
    <!-- VSCode Style Activity Bar -->
    <div class="activity-bar">
        <button class="activity-item active" onclick="showPanel('upload')" title="파일 업로드">
            📁
        </button>
        <button class="activity-item" onclick="showPanel('media')" title="미디어 탐색기">
            📚
        </button>
        <button class="activity-item" onclick="showPanel('subtitle')" title="자막 생성">
            📝
        </button>
        <button class="activity-item" onclick="showPanel('extract')" title="추출">
            📤
        </button>
        <button class="activity-item" onclick="showPanel('translate')" title="번역 및 필터">
            🌐
        </button>
    </div>
    
    <!-- Left Sidebar -->
    <div class="sidebar" id="leftSidebar">
        <div class="sidebar-header" id="sidebarHeader">
            <span>파일 업로드</span>
            <button class="sidebar-toggle" onclick="toggleLeftSidebar()" title="사이드바 숨김/보이기">×</button>
        </div>
        <div class="sidebar-resizer" id="leftSidebarResizer"></div>
        <div class="sidebar-content" id="sidebarContent">
            <!-- 업로드 패널 -->
            <div id="uploadPanel">
                <button onclick="showUploadSection()" style="width: 100%; padding: 10px; margin-bottom: 15px; background: #0e639c; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 0.9em;">
                    ➕ 새 파일 업로드
                </button>
            </div>
            
            <!-- 미디어 패널 -->
            <div id="mediaPanel" style="display: none;">
                <div id="mediaList"></div>
                <div id="chapterList" style="margin-top: 20px; display: none;">
                    <h4>챕터/씬 구조</h4>
                    <div id="chapterContent"></div>
                </div>
            </div>
            
            <!-- 자막 생성 패널 -->
            <div id="subtitlePanel" style="display: none;">
                <div class="extract-options">
                    <h4>📝 자막 생성</h4>
                    <button class="extract-option-btn" onclick="showWhisperOptions()" style="width: 100%; margin-bottom: 8px;">
                        🎤 Whisper 생성
                    </button>
                    <button class="extract-option-btn" onclick="showSrtUpload()" style="width: 100%; margin-bottom: 8px;">
                        📄 SRT 업로드
                    </button>
                    <button class="extract-option-btn delete-btn" onclick="deleteSubtitles()" style="width: 100%; margin-bottom: 15px;">
                        🗑️ 자막 삭제
                    </button>
                    <div id="generationStatus" class="extract-status" style="display: none;"></div>
                </div>
            </div>
            
            <!-- 추출 패널 -->
            <div id="extractPanel" style="display: none;">
                <div class="extract-options">
                    <h4>🎵 MP3 추출</h4>
                    <button class="extract-option-btn" onclick="extractAllMP3()" style="width: 100%; margin-bottom: 8px;">
                        📝 전체 문장 MP3
                    </button>
                    <button class="extract-option-btn" onclick="extractAllChapters()" style="width: 100%; margin-bottom: 8px;">
                        📚 챕터별 추출
                    </button>
                    <button class="extract-option-btn" onclick="extractAllScenes()" style="width: 100%; margin-bottom: 8px;">
                        🎬 씬별 추출
                    </button>
                    <button class="extract-option-btn" onclick="extractBookmarkedOnly()" style="width: 100%; margin-bottom: 15px;">
                        ⭐ 북마크만 추출
                    </button>
                    <div id="extractStatus" class="extract-status" style="margin-bottom: 15px;"></div>
                    
                    <h4>🎬 MP4 추출</h4>
                    <button class="extract-option-btn" onclick="extractAllMP4()" style="width: 100%; margin-bottom: 8px;">
                        📝 전체 문장 MP4
                    </button>
                    <button class="extract-option-btn" onclick="extractAllChaptersMP4()" style="width: 100%; margin-bottom: 8px;">
                        📚 챕터별 MP4 추출
                    </button>
                    <button class="extract-option-btn" onclick="extractAllScenesMP4()" style="width: 100%; margin-bottom: 8px;">
                        🎬 씬별 MP4 추출
                    </button>
                    
                    <!-- 북마크만 MP4 추출 옵션 -->
                    <div style="background: #2a2a2a; padding: 10px; border-radius: 5px; margin-bottom: 8px;">
                        <div style="margin-bottom: 8px; font-weight: bold;">⭐ 북마크만 MP4 추출</div>
                        <div style="margin-bottom: 8px;">
                            <label style="display: inline-block; margin-right: 15px;">
                                <input type="checkbox" id="bookmarkSubtitleEnglish" checked style="margin-right: 5px;">
                                영어 자막
                            </label>
                            <label style="display: inline-block;">
                                <input type="checkbox" id="bookmarkSubtitleKorean" style="margin-right: 5px;">
                                한글 자막
                            </label>
                        </div>
                        <button class="extract-option-btn" onclick="extractBookmarkedOnlyMP4()" style="width: 100%;">
                            ⭐ 북마크만 MP4 생성
                        </button>
                    </div>
                    
                    <!-- 전체 문장 분할 MP4 옵션 -->
                    <div style="background: #2a2a2a; padding: 10px; border-radius: 5px; margin-bottom: 15px;">
                        <div style="margin-bottom: 8px; font-weight: bold;">📝 전체 문장 분할 MP4</div>
                        <div style="margin-bottom: 8px;">
                            <label style="display: inline-block; margin-right: 15px;">
                                <input type="checkbox" id="subtitleEnglish" checked style="margin-right: 5px;">
                                영어 자막
                            </label>
                            <label style="display: inline-block;">
                                <input type="checkbox" id="subtitleKorean" style="margin-right: 5px;">
                                한글 자막
                            </label>
                        </div>
                        <button class="extract-option-btn" onclick="extractAllSentencesMP4()" style="width: 100%;">
                            📝 전체 문장 분할 MP4 생성
                        </button>
                    </div>
                    <div id="extractStatusMP4" class="extract-status" style="margin-bottom: 15px;"></div>
                </div>
            </div>
            
            <!-- 번역 패널 -->
            <div id="translatePanel" style="display: none;">
                <div class="extract-options">
                    <h4>🌐 자동 번역</h4>
                    <div id="translationInfo" style="margin-bottom: 10px; font-size: 0.9em; color: #cccccc;">
                        <!-- 번역 상태 정보가 여기 표시됨 -->
                    </div>
                    <button class="extract-option-btn" onclick="startTranslation()" id="translateBtn" style="width: 100%; margin-bottom: 15px;">
                        🔄 자동 번역 시작
                    </button>
                    <div id="translationStatus" class="extract-status" style="display: none; margin-bottom: 15px;"></div>
                    
                    <h4>🎙️ 오디오 필터</h4>
                    <label style="display: flex; align-items: center; gap: 8px; color: #cccccc; cursor: pointer; margin-bottom: 10px;">
                        <input type="checkbox" id="vadFilter" onchange="toggleVADFilter()">
                        음성 활동 감지 (VAD) 필터
                    </label>
                    <div class="filter-details" id="vadDetails" style="display: none; margin-bottom: 15px;">
                        <div style="margin: 10px 0;">
                            <label>민감도:</label>
                            <input type="range" id="vadThreshold" min="0.1" max="0.9" step="0.1" value="0.3" onchange="updateVADThreshold()">
                            <span id="vadThresholdValue">0.3</span>
                        </div>
                        <button class="extract-option-btn" onclick="applyVADFilter()" style="width: 100%; margin: 5px 0;">
                            🎯 VAD 필터 적용
                        </button>
                        <button class="extract-option-btn" onclick="createVADAudio()" style="width: 100%; margin: 5px 0;">
                            🎵 무음 제거 오디오 생성
                        </button>
                        <div id="vadStatus" style="font-size: 0.8em; color: #858585; margin-top: 5px;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Main Content -->
    <main class="main-content">
        <div id="uploadSection" class="upload-area">
            <h3>📁 미디어 파일 업로드</h3>
            
            <div style="margin-bottom: 15px;">
                <div style="text-align: center; margin-bottom: 15px;">
                    <div style="font-size: 1.2em; color: #cccccc; margin-bottom: 10px;">
                        📁 파일을 여기로 드래그하거나 클릭하여 선택하세요
                    </div>
                    <input type="file" id="fileInput" accept="audio/mp3,audio/mpeg,audio/wav,audio/mp4,audio/m4a,audio/ogg,video/mp4,video/avi,video/mov,video/mkv,video/webm,video/x-flv">
                </div>
                <div style="font-size: 0.8em; color: #858585; text-align: center;">
                    <div><strong>🎵 오디오:</strong> MP3, WAV, M4A, OGG</div>
                    <div><strong>🎬 영상:</strong> MP4, AVI, MOV, MKV, WebM, FLV</div>
                    <div style="margin-top: 5px; color: #606060;">※ 영상 파일은 자동으로 오디오가 추출됩니다</div>
                    <div style="margin-top: 5px; color: #606060;">※ 파일 크기 제한 없음</div>
                </div>
            </div>
            
            <div id="uploadStatus" style="margin-top: 10px; color: #858585;"></div>
            
            <!-- 처리 옵션 (업로드 후 표시) -->
            <div id="processingOptions" style="display: none; margin-top: 20px; padding: 15px; background: #2d2d30; border-radius: 5px;">
                <h4 style="color: #cccccc; margin-bottom: 15px;">📝 문장 생성 방법 선택</h4>
                
                <!-- Whisper 옵션 -->
                <div class="processing-option" style="margin-bottom: 15px; padding: 10px; background: #1e1e1e; border-radius: 5px;">
                    <h5 style="color: #cccccc; margin-bottom: 10px;">🎤 Whisper AI로 문장 생성</h5>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 5px; color: #cccccc; font-size: 0.9em;">모델 선택:</label>
                        <select id="modelSelect" style="width: 100%; padding: 6px; border: 1px solid #444444; background: #2d2d30; color: #cccccc; border-radius: 3px; font-size: 0.9em;">
                            <option value="tiny">⚡ Tiny (빠름, 낮은 정확도)</option>
                            <option value="small">🔹 Small (보통 속도, 보통 정확도)</option>
                            <option value="medium" selected>🔸 Medium (느림, 높은 정확도)</option>
                        </select>
                    </div>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 5px; color: #cccccc; font-size: 0.9em;">구조 템플릿:</label>
                        <select id="templateSelect" style="width: 100%; padding: 6px; border: 1px solid #444444; background: #2d2d30; color: #cccccc; border-radius: 3px; font-size: 0.9em;">
                            <option value="auto">🤖 자동 감지</option>
                            <option value="toeic_lc" selected>📚 TOEIC LC (Part 1-4)</option>
                            <option value="toeic_rc">📖 TOEIC RC (Part 5-7)</option>
                            <option value="general">📝 일반 강의</option>
                            <option value="conversation">💬 대화/인터뷰</option>
                            <option value="audiobook">📚 오디오북</option>
                            <option value="manual">⚙️ 수동 설정</option>
                        </select>
                    </div>
                    
                    <button onclick="processWithWhisper()" style="width: 100%; padding: 10px; background: #0e639c; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        🎤 Whisper로 문장 생성 시작
                    </button>
                </div>
                
                <!-- 문장 업로드 옵션 -->
                <div class="processing-option" style="margin-bottom: 15px; padding: 10px; background: #1e1e1e; border-radius: 5px;">
                    <h5 style="color: #cccccc; margin-bottom: 10px;">📄 문장 데이터 직접 업로드</h5>
                    
                    <div style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 5px; color: #cccccc; font-size: 0.9em;">SRT 파일 업로드:</label>
                        <input type="file" id="srtFileInput" accept=".srt" style="width: 100%; padding: 6px; border: 1px solid #444444; background: #2d2d30; color: #cccccc; border-radius: 3px; font-size: 0.9em;">
                        <div style="font-size: 0.8em; color: #858585; margin-top: 3px;">
                            자막 파일 (.srt) 형식으로 시간 정보와 텍스트를 포함해야 합니다
                        </div>
                    </div>
                    
                    <button onclick="uploadSentences()" style="width: 100%; padding: 10px; background: #4caf50; color: white; border: none; border-radius: 5px; cursor: pointer;">
                        📄 SRT 파일로 문장 생성
                    </button>
                </div>
                
                <div id="processingStatus" style="margin-top: 15px; padding: 10px; background: #1e1e1e; border-radius: 5px; display: none;"></div>
            </div>
        </div>
        

        <div class="media-player" style="display:none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 id="mediaTitle" style="margin: 0;">미디어 제목</h3>
            </div>
            <audio id="audioPlayer" controls preload="auto" style="display:none;">
                브라우저가 오디오 태그를 지원하지 않습니다.
            </audio>
            
            <!-- HTML5 Video Player with Overlay Container -->
            <div id="videoContainer" style="position: relative; display: none; width: 100%;">
                <video
                    id="videoPlayer"
                    controls
                    preload="auto"
                    style="width: 100%; max-width: 100%; height: auto; max-height: 70vh; object-fit: contain; display: block;">
                    브라우저가 비디오를 지원하지 않습니다.
                </video>
                
                <!-- Video Overlay Subtitles -->
                <div id="videoOverlaySubtitles" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 100; color: white; text-align: center; max-width: 90%; display: none; font-family: 'Noto Sans KR', 'Segoe UI', sans-serif; font-size: 3.5em; font-weight: 700; line-height: 1.3; text-shadow: 3px 3px 6px rgba(0, 0, 0, 0.9), 1px 1px 2px rgba(0, 0, 0, 0.8), -1px -1px 2px rgba(0, 0, 0, 0.8);">
                    오버레이 자막이 여기에 표시됩니다
                </div>
            </div>
            
            <!-- 오버레이 자막 컨트롤 패널 -->
            <div id="overlayControlPanel" style="margin-top: 15px; padding: 12px; background: #2a2a2a; border-radius: 8px; border: 1px solid #444444; display: block;">
                <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">
                    <!-- 언어 선택 -->
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="color: #cccccc; font-size: 0.9em; min-width: 60px;">🗣️ 언어:</span>
                        <button id="subtitleEngBtn" onclick="setSubtitleLanguage('english')" style="padding: 4px 8px; background: #0e639c; color: #ffffff; border: 1px solid #0e639c; border-radius: 4px; cursor: pointer; font-size: 0.9em;">EN</button>
                        <button id="subtitleKorBtn" onclick="setSubtitleLanguage('korean')" style="padding: 4px 8px; background: #333333; color: #cccccc; border: 1px solid #555555; border-radius: 4px; cursor: pointer; font-size: 0.9em;">한</button>
                        <button id="subtitleBothBtn" onclick="setSubtitleLanguage('both')" style="padding: 4px 8px; background: #333333; color: #cccccc; border: 1px solid #555555; border-radius: 4px; cursor: pointer; font-size: 0.9em;">둘다</button>
                        <button id="verbHighlightBtn" onclick="toggleVerbHighlight()" style="padding: 4px 8px; background: #ffeb3b; color: #333; border: 1px solid #ffeb3b; border-radius: 4px; cursor: pointer; font-size: 0.9em; margin-left: 8px;">💛ON</button>
                        <button id="verbModeBtn" onclick="toggleVerbMode()" style="padding: 4px 8px; background: #333333; color: #cccccc; border: 1px solid #555555; border-radius: 4px; cursor: pointer; font-size: 0.9em;" title="하이라이트 모드 (클릭하면 빈칸 모드)">🔆</button>
                    </div>
                    
                    <!-- 크기 조절 -->
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="color: #cccccc; font-size: 0.9em; min-width: 60px;">📏 크기:</span>
                        <button onclick="adjustOverlaySize(-0.2)" style="padding: 4px 8px; background: #333333; color: #cccccc; border: 1px solid #555555; border-radius: 4px; cursor: pointer; font-size: 0.9em;">－</button>
                        <span id="overlaySizeDisplay" style="color: #ffffff; font-size: 0.9em; min-width: 40px; text-align: center;">120%</span>
                        <button onclick="adjustOverlaySize(0.2)" style="padding: 4px 8px; background: #333333; color: #cccccc; border: 1px solid #555555; border-radius: 4px; cursor: pointer; font-size: 0.9em;">＋</button>
                        <button onclick="resetOverlaySize()" style="padding: 4px 10px; background: #444444; color: #cccccc; border: 1px solid #666666; border-radius: 4px; cursor: pointer; font-size: 0.8em; margin-left: 5px;">초기화</button>
                    </div>
                    
                    <!-- 위치 조절 -->
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="color: #cccccc; font-size: 0.9em; min-width: 60px;">📍 위치:</span>
                        <button id="positionCenterBtn" onclick="setOverlayPosition('center')" style="padding: 4px 12px; background: #0e639c; color: #ffffff; border: 1px solid #0e639c; border-radius: 4px; cursor: pointer; font-size: 0.9em;">중앙</button>
                        <button id="positionBottomBtn" onclick="setOverlayPosition('bottom')" style="padding: 4px 12px; background: #333333; color: #cccccc; border: 1px solid #555555; border-radius: 4px; cursor: pointer; font-size: 0.9em;">하단</button>
                    </div>
                </div>
            </div>
            
            <!-- Language Reactor 스타일 자막 표시 영역 -->
            <div id="videoSubtitlesContainer" style="margin-top: 20px; min-height: 200px; position: relative;">
                <!-- 자막 토글 버튼 -->
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <div style="color: #888888; font-size: 0.9em;">🎬 실시간 자막</div>
                    <div style="display: flex; gap: 8px;">
                        <button id="subtitleToggleBtn" onclick="toggleSubtitleDisplay()" style="padding: 5px 10px; background: #333333; color: #cccccc; border: 1px solid #444444; border-radius: 5px; cursor: pointer; font-size: 0.85em;">
                            🔽 숨기기
                        </button>
                    </div>
                </div>
                
                <div id="videoSubtitles" style="background: #1e1e1e; border-radius: 10px; padding: 20px; border: 2px solid #333333; height: 180px; min-height: 180px; max-height: 180px; display: flex; flex-direction: column; justify-content: center; overflow: hidden;">
                    <!-- 이전 자막 -->
                    <div id="previousSubtitle" style="text-align: center; padding: 8px 15px; color: #888888; font-size: 0.9em; line-height: 1.4; margin-bottom: 10px; opacity: 0.6; min-height: 20px;">
                    </div>
                    
                    <!-- 현재 자막 -->
                    <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                        <div id="currentSubtitle" style="flex: 1; text-align: center; font-size: 1.4em; color: #ffffff; line-height: 1.6; padding: 15px 20px; background: #2d2d30; border-radius: 8px; border: 2px solid #0e639c; font-weight: 500; font-family: 'Segoe UI', 'Noto Sans KR', sans-serif; min-height: 60px; display: flex; align-items: center; justify-content: center;">
                            자막이 여기에 표시됩니다
                        </div>
                        <button id="subtitleBookmarkBtn" onclick="toggleSubtitleBookmark()" style="padding: 10px 14px; background: #333333; color: #cccccc; border: 1px solid #444444; border-radius: 8px; cursor: pointer; font-size: 1em; white-space: nowrap; transition: all 0.2s;" title="북마크 추가/제거">
                            ☆
                        </button>
                    </div>
                    
                    <!-- 현재 자막 번역 -->
                    <div id="currentSubtitleKorean" style="text-align: center; color: #cccccc; font-size: 1.1em; line-height: 1.5; margin-bottom: 15px; font-family: 'Noto Sans KR', sans-serif; min-height: 20px;">
                    </div>
                    
                    <!-- 다음 자막 -->
                    <div id="nextSubtitle" style="text-align: center; padding: 8px 15px; color: #888888; font-size: 0.9em; line-height: 1.4; opacity: 0.6; min-height: 20px;">
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 10px; font-size: 0.9em; color: #858585;">
                문장을 클릭하면 해당 구간이 재생됩니다.
            </div>
        </div>
        
        <div class="controls">
            <button class="btn" onclick="repeatCurrent()">구간 반복</button>
            <button class="btn" onclick="playBookmarked()">북마크 재생</button>
            <button class="btn btn-export" onclick="exportBookmarks()">북마크 내보내기</button>
        </div>
        
    </main>
    
    <!-- Right Sidebar -->
    <div class="right-sidebar" id="rightSidebar">
        <div class="right-sidebar-header">
            <span>문장 목록</span>
            <button class="sidebar-toggle" onclick="toggleRightSidebar()" title="사이드바 숨김/보이기">×</button>
        </div>
        <div class="right-sidebar-resizer" id="rightSidebarResizer"></div>
        <div class="right-sidebar-content">
        
            <!-- 문장 검색 -->
            <div class="search-area" style="margin-bottom: 20px;">
                <h3>문장 검색</h3>
                <input type="text" id="searchInput" placeholder="3글자 이상 입력하면 자동 검색..." 
                       style="width: 100%; padding: 10px; border: 1px solid #444444; background: #2d2d30; color: #cccccc; border-radius: 3px;">
                <div id="searchResults" style="margin-top: 10px; color: #858585;"></div>
            </div>
            
            <!-- 문장 목록 -->
            <div id="sentenceList"></div>
            
            <!-- 북마크된 문장 -->
            <div class="bookmarked-panel">
                <h3>⭐ 북마크된 문장</h3>
                <div id="bookmarkedList"></div>
            </div>
        </div>
    </div>
    
    <!-- Whisper 모달 -->
    <div id="whisperModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>🎤 Whisper 자막 생성</h3>
                <button class="modal-close" onclick="closeModal('whisperModal')">&times;</button>
            </div>
            <div class="modal-form">
                <div>
                    <label>모델 선택:</label>
                    <select id="modalModelSelect">
                        <option value="tiny">⚡ Tiny (빠름, 낮은 정확도)</option>
                        <option value="small">🔹 Small (보통 속도, 보통 정확도)</option>
                        <option value="medium" selected>🔸 Medium (느림, 높은 정확도)</option>
                    </select>
                </div>
                <div>
                    <label>구조 템플릿:</label>
                    <select id="modalTemplateSelect">
                        <option value="auto">🤖 자동 감지</option>
                        <option value="toeic_lc" selected>📚 TOEIC LC (Part 1-4)</option>
                        <option value="toeic_rc">📖 TOEIC RC (Part 5-7)</option>
                        <option value="general">📝 일반 강의</option>
                        <option value="conversation">💬 대화/인터뷰</option>
                        <option value="audiobook">📚 오디오북</option>
                        <option value="manual">⚙️ 수동 설정</option>
                    </select>
                </div>
                <button onclick="startModalWhisper()">🎤 Whisper 생성 시작</button>
            </div>
        </div>
    </div>
    
    <!-- SRT 업로드 모달 -->
    <div id="srtModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3>📄 SRT 자막 업로드</h3>
                <button class="modal-close" onclick="closeModal('srtModal')">&times;</button>
            </div>
            <div class="modal-form">
                <div>
                    <label>SRT 파일 선택:</label>
                    <input type="file" id="modalSrtFileInput" accept=".srt">
                    <div style="font-size: 0.8em; color: #858585; margin-top: 5px;">
                        자막 파일 (.srt) 형식으로 시간 정보와 텍스트를 포함해야 합니다
                    </div>
                </div>
                <button class="srt-btn" onclick="startModalSrtUpload()">📄 SRT 업로드 시작</button>
            </div>
        </div>
    </div>
    
    <script>
        let currentMedia = null;
        let sentences = [];
        let audioPlayer = null;
        let videoPlayer = null;
        let currentPlayer = null; // 현재 사용 중인 플레이어
        let currentSentenceIndex = -1;
        let currentSubtitleSentence = null; // 현재 표시 중인 자막의 문장 정보
        let subtitleDisplayVisible = true; // 자막 표시 상태
        let translationInterval = null;
        let uploadedMediaId = null;
        
        // VSCode 스타일 패널 전환 함수 (전역 스코프에서 정의)
        window.showPanel = function(panelType) {
            // 모든 activity item에서 active 클래스 제거
            document.querySelectorAll('.activity-item').forEach(item => {
                item.classList.remove('active');
            });
            
            // 클릭된 버튼에 active 클래스 추가 (이벤트가 있는 경우만)
            if (typeof window.event !== 'undefined' && window.event && window.event.target) {
                window.event.target.classList.add('active');
            } else {
                // 프로그래밍적으로 호출된 경우 해당 패널 버튼 찾아서 활성화
                const buttons = document.querySelectorAll('.activity-item');
                if (panelType === 'upload') buttons[0]?.classList.add('active');
                if (panelType === 'media') buttons[1]?.classList.add('active');
                if (panelType === 'subtitle') buttons[2]?.classList.add('active');
                if (panelType === 'extract') buttons[3]?.classList.add('active');
                if (panelType === 'translate') buttons[4]?.classList.add('active');
            }
            
            // 모든 패널 숨기기
            const panels = ['uploadPanel', 'mediaPanel', 'subtitlePanel', 'extractPanel', 'translatePanel'];
            panels.forEach(panelId => {
                const panel = document.getElementById(panelId);
                if (panel) panel.style.display = 'none';
            });
            
            // 선택된 패널 표시
            const headerEl = document.getElementById('sidebarHeader');
            switch(panelType) {
                case 'upload':
                    const uploadPanel = document.getElementById('uploadPanel');
                    if (uploadPanel) uploadPanel.style.display = 'block';
                    if (headerEl) headerEl.innerHTML = '<span>파일 업로드</span><button class="sidebar-toggle" onclick="toggleLeftSidebar()" title="사이드바 숨김/보이기">×</button>';
                    break;
                case 'media':
                    const mediaPanel = document.getElementById('mediaPanel');
                    if (mediaPanel) mediaPanel.style.display = 'block';
                    if (headerEl) headerEl.innerHTML = '<span>미디어 탐색기</span><button class="sidebar-toggle" onclick="toggleLeftSidebar()" title="사이드바 숨김/보이기">×</button>';
                    loadMediaList(); // 미디어 목록 새로고침
                    break;
                case 'subtitle':
                    const subtitlePanel = document.getElementById('subtitlePanel');
                    if (subtitlePanel) subtitlePanel.style.display = 'block';
                    if (headerEl) headerEl.innerHTML = '<span>자막 생성</span><button class="sidebar-toggle" onclick="toggleLeftSidebar()" title="사이드바 숨김/보이기">×</button>';
                    break;
                case 'extract':
                    const extractPanel = document.getElementById('extractPanel');
                    if (extractPanel) extractPanel.style.display = 'block';
                    if (headerEl) headerEl.innerHTML = '<span>추출</span><button class="sidebar-toggle" onclick="toggleLeftSidebar()" title="사이드바 숨김/보이기">×</button>';
                    break;
                case 'translate':
                    const translatePanel = document.getElementById('translatePanel');
                    if (translatePanel) translatePanel.style.display = 'block';
                    if (headerEl) headerEl.innerHTML = '<span>번역 및 필터</span><button class="sidebar-toggle" onclick="toggleLeftSidebar()" title="사이드바 숨김/보이기">×</button>';
                    break;
            }
        };
        
        document.addEventListener('DOMContentLoaded', function() {
            audioPlayer = document.getElementById('audioPlayer');
            videoPlayer = document.getElementById('videoPlayer');
            
            // HTML5 비디오 이벤트 리스너
            videoPlayer.addEventListener('timeupdate', updateVideoSubtitles);
            
            // HTML5 오디오 이벤트 리스너
            audioPlayer.addEventListener('timeupdate', updateAudioSubtitles);
            
            // 버튼 초기화
            updateVerbHighlightButton();
            updateVerbModeButton();
            
            // 키보드 이벤트 리스너 추가
            document.addEventListener('keydown', handleKeyboardControls);
            
            // 파일 업로드 처리
            document.getElementById('fileInput').addEventListener('change', handleFileUpload);
            
            // 드래그 앤 드롭 설정
            setupDragAndDrop();
            
            // 검색 입력 처리
            document.getElementById('searchInput').addEventListener('input', handleSearchInput);
            
            // 미디어 목록 로드
            loadMediaList();
            
            // 기본적으로 미디어 패널 표시 (미디어가 있는 경우)
            setTimeout(() => {
                const mediaListEl = document.getElementById('mediaList');
                if (mediaListEl && !mediaListEl.innerHTML.includes('업로드된 미디어가 없습니다')) {
                    showPanel('media');
                }
            }, 500);
            
            // 초기 상태: 업로드 섹션 표시, 다른 섹션들 숨김
            document.getElementById('uploadSection').style.display = 'block';
            document.getElementById('processingOptions').style.display = 'none';
            // document.getElementById('searchSection').style.display = 'none'; // 요소가 존재하지 않음
            
            // 시뮬레이션 데이터 로드 (개발용)
            // loadSimulationData();
            
            // 사이드바 리사이즈 기능 초기화
            initSidebarResize();
            
            // 윈도우 리사이즈 이벤트
            window.addEventListener('resize', updateVideoSize);
        });
        
        function setupDragAndDrop() {
            const uploadArea = document.querySelector('.upload-area');
            
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, preventDefaults, false);
            });
            
            function preventDefaults(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            ['dragenter', 'dragover'].forEach(eventName => {
                uploadArea.addEventListener(eventName, highlight, false);
            });
            
            ['dragleave', 'drop'].forEach(eventName => {
                uploadArea.addEventListener(eventName, unhighlight, false);
            });
            
            function highlight(e) {
                uploadArea.classList.add('drag-over');
            }
            
            function unhighlight(e) {
                uploadArea.classList.remove('drag-over');
            }
            
            uploadArea.addEventListener('drop', handleDrop, false);
            
            function handleDrop(e) {
                const dt = e.dataTransfer;
                const files = dt.files;
                
                if (files.length > 0) {
                    // 첫 번째 파일만 처리
                    const file = files[0];
                    const supportedFormats = /\.(mp3|wav|m4a|ogg|mp4|avi|mov|mkv|webm|flv)$/i;
                    
                    if (supportedFormats.test(file.name)) {
                        handleFileUpload({ target: { files: [file] } });
                    } else {
                        const statusEl = document.getElementById('uploadStatus');
                        statusEl.innerHTML = `❌ 지원하지 않는 파일 형식: ${file.name}`;
                    }
                }
            }
        }
        
        function handleFileUpload(event) {
            const files = event.target.files;
            if (files.length === 0) return;
            
            const statusEl = document.getElementById('uploadStatus');
            const file = files[0];
            
            // 파일 타입 확인
            const isVideo = /\.(mp4|avi|mov|mkv|webm|flv)$/i.test(file.name);
            const isAudio = /\.(mp3|wav|m4a|ogg)$/i.test(file.name);
            
            if (isVideo) {
                statusEl.innerHTML = `🎬 영상 파일 업로드 중... (${file.name})`;
            } else if (isAudio) {
                statusEl.innerHTML = `🎵 오디오 파일 업로드 중... (${file.name})`;
            } else {
                statusEl.innerHTML = `📁 파일 업로드 중... (${file.name})`;
            }
            
            const formData = new FormData();
            formData.append('file', file);
            
            // 파일 크기 표시만 (제한 없음)
            // if (file.size > 500 * 1024 * 1024) {
            //     statusEl.innerHTML = `❌ 파일이 너무 큽니다 (${Math.round(file.size / 1024 / 1024)}MB). 최대 500MB까지 지원됩니다.`;
            //     return;
            // }
            
            statusEl.innerHTML += ` (${Math.round(file.size / 1024 / 1024)}MB)`;
            
            // AbortController로 타임아웃 제어
            const controller = new AbortController();
            const timeoutId = setTimeout(() => {
                controller.abort();
                statusEl.innerHTML = `❌ 업로드 타임아웃 (10분 제한): ${file.name}`;
            }, 10 * 60 * 1000); // 10분 타임아웃
            
            fetch('/api/upload', {
                method: 'POST',
                body: formData,
                signal: controller.signal
            })
            .then(response => {
                clearTimeout(timeoutId);
                console.log('Upload response status:', response.status, response.statusText);
                
                if (!response.ok) {
                    return response.json().then(errorData => {
                        console.error('Upload server error response:', errorData);
                        throw new Error(`Server error: ${errorData.error || response.statusText}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    if (isVideo) {
                        statusEl.innerHTML = `✅ 영상 업로드 완료 (오디오 추출됨): ${file.name}`;
                    } else {
                        statusEl.innerHTML = `✅ 업로드 완료: ${file.name}`;
                    }
                    
                    // 업로드된 미디어 ID 저장
                    uploadedMediaId = data.media_id;
                    
                    // 플레이어에 파일 로드 (영상/오디오 구분)
                    const mediaTitle = document.getElementById('mediaTitle');
                    const mediaPlayerDiv = document.querySelector('.media-player');
                    
                    // 영상 파일 확인
                    const videoExtensions = ['mp4', 'avi', 'mov', 'mkv', 'webm', 'flv'];
                    const fileExt = data.filename.toLowerCase().split('.').pop();
                    const isVideo = videoExtensions.includes(fileExt);
                    
                    if (isVideo) {
                        // HTML5 비디오 플레이어 사용
                        const videoSrc = `/api/audio/${data.filename}`;
                        console.log('Loading uploaded video:', videoSrc);
                        
                        videoPlayer.src = videoSrc;
                        videoPlayer.load();
                        
                        document.getElementById('videoContainer').style.display = 'block';
                        audioPlayer.style.display = 'none';
                        document.getElementById('videoSubtitlesContainer').style.display = 'block';
                        currentPlayer = videoPlayer;
                        
                        // 비디오 로드 후 크기 업데이트
                        videoPlayer.addEventListener('loadedmetadata', updateVideoSize, { once: true });
                    } else {
                        // 오디오 플레이어 사용
                        audioPlayer.src = `/api/audio/${data.filename}`;
                        audioPlayer.style.display = 'block';
                        document.getElementById('videoContainer').style.display = 'none';
                        document.getElementById('videoSubtitlesContainer').style.display = 'none';
                        currentPlayer = audioPlayer;
                    }
                    
                    mediaTitle.textContent = data.original_filename;
                    mediaPlayerDiv.style.display = 'block';
                    
                    console.log(`Media loaded: ${data.original_filename}`);
                    
                    // 처리 옵션 표시
                    document.getElementById('processingOptions').style.display = 'block';
                    
                    // 미디어 목록 새로고침
                    loadMediaList();
                } else {
                    if (isVideo && data.error.includes('extract audio')) {
                        statusEl.innerHTML = `❌ 영상에서 오디오 추출 실패: ${file.name}`;
                    } else {
                        statusEl.innerHTML = `❌ 업로드 실패: ${file.name} - ${data.error}`;
                    }
                    console.error('Upload error:', data.error);
                }
            })
            .catch(error => {
                clearTimeout(timeoutId);
                console.error('Upload error:', error);
                
                if (error.name === 'AbortError') {
                    statusEl.innerHTML = `❌ 업로드 타임아웃: ${file.name}`;
                } else if (error.message.includes('Failed to fetch')) {
                    statusEl.innerHTML = `❌ 네트워크 오류 (연결 중단): ${file.name}. 파일이 너무 크거나 서버 문제일 수 있습니다.`;
                } else {
                    statusEl.innerHTML = `❌ 업로드 중 오류 발생: ${error.message}`;
                }
            });
        }
        
        // 새로운 처리 함수들
        function processWithWhisper() {
            if (!uploadedMediaId) {
                const statusEl = document.getElementById('processingStatus');
                statusEl.style.display = 'block';
                statusEl.innerHTML = '❌ 먼저 오디오 파일을 업로드하세요.';
                return;
            }
            
            const model = document.getElementById('modelSelect').value;
            const template = document.getElementById('templateSelect').value;
            const statusEl = document.getElementById('processingStatus');
            
            statusEl.style.display = 'block';
            statusEl.innerHTML = `🎤 Whisper 처리 시작 중... (모델: ${model}, 템플릿: ${template})`;
            
            fetch(`/api/media/${uploadedMediaId}/process-whisper`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({
                    model: model,
                    template: template
                })
            })
            .then(response => {
                console.log('Response status:', response.status, response.statusText);
                if (!response.ok) {
                    return response.json().then(errorData => {
                        console.error('Server error response:', errorData);
                        
                        // 처리 중인 미디어인 경우 강제 재시작 옵션 제공
                        if (errorData.can_force_restart) {
                            if (confirm('미디어가 현재 처리 중입니다. 강제로 재시작하시겠습니까?')) {
                                // 강제 재시작으로 다시 요청
                                return fetch(`/api/media/${uploadedMediaId}/process-whisper`, {
                                    method: 'POST',
                                    headers: {'Content-Type': 'application/json'},
                                    body: JSON.stringify({
                                        model: model,
                                        template: template,
                                        force_restart: true
                                    })
                                }).then(response => response.json());
                            } else {
                                throw new Error('처리가 취소되었습니다.');
                            }
                        }
                        
                        throw new Error(`Server error: ${errorData.error || response.statusText}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    statusEl.innerHTML = `✅ ${data.message}`;
                    currentMedia = uploadedMediaId;
                    
                    // 자막 생성 상태 업데이트 및 자막 패널로 전환
                    const generationStatusEl = document.getElementById('generationStatus');
                    if (generationStatusEl) {
                        generationStatusEl.innerHTML = `🎤 Whisper 처리 중... 상태를 모니터링합니다.`;
                    }
                    showPanel('subtitle');
                    
                    // 처리 상태 모니터링 시작
                    monitorProcessingStatus();
                } else {
                    statusEl.innerHTML = `❌ 처리 실패: ${data.error}`;
                    
                    // 자막 생성 상태 오류 표시
                    const generationStatusEl = document.getElementById('generationStatus');
                    if (generationStatusEl) {
                        generationStatusEl.innerHTML = `❌ 자막 생성 실패: ${data.error}`;
                    }
                }
            })
            .catch(error => {
                console.error('Whisper processing error:', error);
                statusEl.innerHTML = `❌ 처리 중 오류 발생: ${error.message}`;
                
                // 자막 생성 상태 오류 표시
                const generationStatusEl = document.getElementById('generationStatus');
                if (generationStatusEl) {
                    generationStatusEl.innerHTML = `❌ 처리 중 오류 발생: ${error.message}`;
                }
            });
        }
        
        function uploadSentences() {
            if (!uploadedMediaId) {
                const statusEl = document.getElementById('processingStatus');
                statusEl.style.display = 'block';
                statusEl.innerHTML = '❌ 먼저 오디오 파일을 업로드하세요.';
                return;
            }
            
            const srtFile = document.getElementById('srtFileInput').files[0];
            if (!srtFile) {
                const statusEl = document.getElementById('processingStatus');
                statusEl.style.display = 'block';
                statusEl.innerHTML = '❌ SRT 파일을 선택하세요.';
                return;
            }
            
            const statusEl = document.getElementById('processingStatus');
            const formData = new FormData();
            formData.append('file', srtFile);
            formData.append('template', 'manual');
            
            statusEl.style.display = 'block';
            statusEl.innerHTML = `📄 SRT 파일 처리 중...`;
            
            fetch(`/api/media/${uploadedMediaId}/upload-sentences`, {
                method: 'POST',
                body: formData
            })
            .then(response => {
                console.log('SRT Upload Response status:', response.status, response.statusText);
                if (!response.ok) {
                    return response.json().then(errorData => {
                        console.error('SRT Upload Server error response:', errorData);
                        throw new Error(`Server error: ${errorData.error || response.statusText}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    statusEl.innerHTML = `✅ ${data.message}`;
                    currentMedia = uploadedMediaId;
                    
                    // 자막 생성 상태 업데이트
                    const generationStatusEl = document.getElementById('generationStatus');
                    if (generationStatusEl) {
                        generationStatusEl.innerHTML = `📄 SRT 파일 처리 완료`;
                    }
                    
                    // 처리 상태 모니터링 시작
                    monitorProcessingStatus();
                } else {
                    statusEl.innerHTML = `❌ 처리 실패: ${data.error}`;
                    
                    // 자막 생성 상태 오류 표시
                    const generationStatusEl = document.getElementById('generationStatus');
                    if (generationStatusEl) {
                        generationStatusEl.innerHTML = `❌ SRT 업로드 실패: ${data.error}`;
                    }
                }
            })
            .catch(error => {
                console.error('Sentence upload error:', error);
                statusEl.innerHTML = `❌ 처리 중 오류 발생: ${error.message}`;
                
                // 자막 생성 상태 오류 표시
                const generationStatusEl = document.getElementById('generationStatus');
                if (generationStatusEl) {
                    generationStatusEl.innerHTML = `❌ SRT 업로드 오류: ${error.message}`;
                }
            });
        }
        
        function monitorProcessingStatus() {
            const statusEl = document.getElementById('processingStatus');
            
            const interval = setInterval(() => {
                fetch(`/api/media/${uploadedMediaId}/status`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.processed && data.sentence_count > 0) {
                            clearInterval(interval);
                            statusEl.innerHTML = `✅ 처리 완료! ${data.sentence_count}개 문장 생성됨`;
                            
                            // 문장 로드 및 표시
                            loadGroupedSentences(uploadedMediaId);
                            checkTranslationStatus();
                            
                            // 처리 옵션 숨기기
                            document.getElementById('processingOptions').style.display = 'none';
                        } else if (data.status === 'processing' && data.current_sentence) {
                            statusEl.innerHTML = `🔄 ${data.current_sentence}`;
                        } else if (data.status === 'error') {
                            clearInterval(interval);
                            statusEl.innerHTML = `❌ 처리 오류: ${data.current_sentence}`;
                        }
                    })
                    .catch(error => {
                        console.error('Status check error:', error);
                    });
            }, 2000);
        }
        
        function checkProcessingStatus(mediaId, filename) {
            const statusEl = document.getElementById('uploadStatus');
            let checkCount = 0;
            let lastSentenceCount = 0;
            
            const interval = setInterval(() => {
                checkCount++;
                
                fetch(`/api/media/${mediaId}/status`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.processed && data.sentence_count > 0) {
                            clearInterval(interval);
                            
                            // 최종 문장 로드
                            if (mediaId === currentMedia) {
                                loadMediaSentences(mediaId);
                            }
                            
                            console.log(`${filename}: 처리 완료! ${data.sentence_count}개 문장 추출`);
                            
                            if (statusEl) {
                                statusEl.innerHTML = `${filename}: 처리 완료! ${data.sentence_count}개 문장`;
                            }
                        } else {
                            // 실시간 문장 업데이트
                            if (data.sentence_count > lastSentenceCount) {
                                lastSentenceCount = data.sentence_count;
                                
                                // 새로운 문장이 추가되면 즉시 화면 업데이트
                                if (mediaId === currentMedia) {
                                    loadMediaSentences(mediaId);
                                }
                            }
                            
                            // 처리 중 상태 표시 (현재 문장 포함)
                            if (statusEl) {
                                const dots = '.'.repeat((checkCount % 3) + 1);
                                
                                // 현재 처리 중인 문장 표시
                                if (data.current_sentence && data.current_sentence.trim()) {
                                    statusEl.innerHTML = `
                                        <div>${filename} (${data.status || '처리 중'})${dots}</div>
                                        <div style="font-size: 0.85em; color: #aaa; margin-top: 3px;">${data.current_sentence}</div>
                                        <div style="font-size: 0.8em; color: #888;">${data.sentence_count}개 문장 완료</div>
                                    `;
                                } else if (data.sentence_count > 0) {
                                    statusEl.innerHTML = `${filename}: ${data.sentence_count}개 문장 추출됨${dots}`;
                                } else {
                                    statusEl.innerHTML = `${filename} 처리 중${dots}`;
                                }
                            }
                            
                            // 30분 후 타임아웃 (대용량 파일 고려)
                            if (checkCount > 1800) {  // 30분
                                clearInterval(interval);
                                if (statusEl) {
                                    statusEl.innerHTML = `${filename}: 처리 시간 초과 (30분)`;
                                }
                            }
                        }
                    })
                    .catch(error => {
                        console.error('Status check error:', error);
                        if (statusEl) {
                            statusEl.innerHTML = `${filename}: 상태 확인 오류`;
                        }
                        clearInterval(interval);
                    });
            }, 1000); // 1초마다 확인 (더 빠른 업데이트)
        }
        
        function loadMediaList() {
            console.log('Loading media list...');
            fetch('/api/media')
                .then(response => {
                    console.log('Media API response:', response.status);
                    return response.json();
                })
                .then(media => {
                    console.log('Media data:', media);
                    const listEl = document.getElementById('mediaList');
                    if (!listEl) {
                        console.error('mediaList element not found!');
                        return;
                    }
                    
                    if (media.length === 0) {
                        listEl.innerHTML = '<div style="color: #858585; padding: 10px;">업로드된 미디어가 없습니다.</div>';
                    } else {
                        listEl.innerHTML = media.map(m => {
                            // UUID 제거: UUID는 36자리 (8-4-4-4-12) 형태이므로 첫 37자(UUID + _)를 제거
                            const displayName = m.filename.includes('_') ? 
                                m.filename.substring(m.filename.indexOf('_') + 1) : 
                                m.filename;
                            
                            return `
                            <div class="media-item" onclick="loadMediaSentences('${m.id}')" data-media-id="${m.id}">
                                <div style="font-weight: bold;" title="${displayName}">${displayName}</div>
                                <div style="font-size: 0.8em; color: #858585;">
                                    ${m.createdAt ? new Date(m.createdAt).toLocaleDateString() : ''}
                                </div>
                                <button class="delete-btn" onclick="deleteMedia('${m.id}', event)" 
                                        style="position: absolute; right: 5px; top: 5px; background: #d32f2f; color: white; border: none; padding: 3px 6px; border-radius: 3px; cursor: pointer; font-size: 10px;">
                                    ✕
                                </button>
                            </div>
                            `;
                        }).join('');
                    }
                    console.log(`Media list updated: ${media.length} items`);
                })
                .catch(error => {
                    console.error('Failed to load media list:', error);
                    const listEl = document.getElementById('mediaList');
                    if (listEl) {
                        listEl.innerHTML = '<div style="color: #ff6b6b;">미디어 목록 로딩 실패</div>';
                    }
                });
        }
        
        // 사이드바 토글 함수들
        function toggleLeftSidebar() {
            const sidebar = document.getElementById('leftSidebar');
            sidebar.classList.toggle('collapsed');
            
            // 토글 버튼 텍스트 변경
            const toggleBtn = sidebar.querySelector('.sidebar-toggle');
            if (sidebar.classList.contains('collapsed')) {
                toggleBtn.innerHTML = '▶';
                toggleBtn.style.position = 'fixed';
                toggleBtn.style.left = '10px';
                toggleBtn.style.top = '10px';
                toggleBtn.style.zIndex = '1001';
                toggleBtn.style.background = '#252526';
                toggleBtn.style.border = '1px solid #444444';
            } else {
                toggleBtn.innerHTML = '×';
                toggleBtn.style.position = 'static';
                toggleBtn.style.background = 'none';
                toggleBtn.style.border = 'none';
            }
        }
        
        function toggleRightSidebar() {
            const sidebar = document.getElementById('rightSidebar');
            sidebar.classList.toggle('collapsed');
            
            // 토글 버튼 텍스트 변경
            const toggleBtn = sidebar.querySelector('.sidebar-toggle');
            if (sidebar.classList.contains('collapsed')) {
                toggleBtn.innerHTML = '◀';
                toggleBtn.style.position = 'fixed';
                toggleBtn.style.right = '10px';
                toggleBtn.style.top = '10px';
                toggleBtn.style.zIndex = '1001';
                toggleBtn.style.background = '#252526';
                toggleBtn.style.border = '1px solid #444444';
            } else {
                toggleBtn.innerHTML = '×';
                toggleBtn.style.position = 'static';
                toggleBtn.style.background = 'none';
                toggleBtn.style.border = 'none';
            }
        }
        
        // 디버깅용 전역 함수
        window.testRightSidebarResizer = function() {
            const rightResizer = document.getElementById('rightSidebarResizer');
            const rightSidebar = document.getElementById('rightSidebar');
            
            console.log('=== Right Sidebar Resizer Debug ===');
            console.log('Resizer element:', rightResizer);
            console.log('Sidebar element:', rightSidebar);
            
            if (rightResizer) {
                console.log('Resizer bounding rect:', rightResizer.getBoundingClientRect());
                console.log('Resizer computed style:', getComputedStyle(rightResizer));
                console.log('Resizer parent:', rightResizer.parentElement);
                console.log('Resizer z-index:', getComputedStyle(rightResizer).zIndex);
                console.log('Resizer display:', getComputedStyle(rightResizer).display);
                console.log('Resizer position:', getComputedStyle(rightResizer).position);
                
                // 강제로 이벤트 테스트
                rightResizer.style.background = 'yellow';
                rightResizer.style.border = '5px solid purple';
                console.log('Resizer styled with yellow background and purple border');
            } else {
                console.error('Right resizer not found!');
            }
            
            if (rightSidebar) {
                console.log('Sidebar bounding rect:', rightSidebar.getBoundingClientRect());
                console.log('Sidebar computed style position:', getComputedStyle(rightSidebar).position);
            }
        };
        
        // 사이드바 리사이즈 기능
        function initSidebarResize() {
            console.log('Initializing sidebar resize...');
            let isResizing = false;
            let currentSidebar = null;
            
            // DOM 상태 확인
            console.log('DOM ready state:', document.readyState);
            console.log('All elements:', {
                'leftSidebarResizer': document.getElementById('leftSidebarResizer'),
                'leftSidebar': document.getElementById('leftSidebar'),
                'rightSidebarResizer': document.getElementById('rightSidebarResizer'),
                'rightSidebar': document.getElementById('rightSidebar')
            });
            
            // 왼쪽 사이드바 리사이저
            const leftResizer = document.getElementById('leftSidebarResizer');
            const leftSidebar = document.getElementById('leftSidebar');
            
            console.log('Left resizer:', leftResizer);
            console.log('Left sidebar:', leftSidebar);
            
            if (leftResizer && leftSidebar) {
                leftResizer.addEventListener('mousedown', (e) => {
                    console.log('Left resizer mousedown');
                    isResizing = true;
                    currentSidebar = leftSidebar;
                    document.body.style.cursor = 'ew-resize';
                    document.body.style.userSelect = 'none';
                    e.preventDefault();
                });
            }
            
            // 오른쪽 사이드바 리사이저
            const rightResizer = document.getElementById('rightSidebarResizer');
            const rightSidebar = document.getElementById('rightSidebar');
            
            console.log('Right resizer:', rightResizer);
            console.log('Right sidebar:', rightSidebar);
            console.log('Right resizer computed style:', rightResizer ? getComputedStyle(rightResizer) : 'null');
            
            if (rightResizer && rightSidebar) {
                // 마우스 이벤트 로깅을 위한 추가 이벤트 리스너
                rightResizer.addEventListener('mouseenter', () => {
                    console.log('Right resizer mouse enter');
                });
                
                rightResizer.addEventListener('mouseleave', () => {
                    console.log('Right resizer mouse leave');
                });
                
                rightResizer.addEventListener('mousedown', (e) => {
                    console.log('Right resizer mousedown event fired!', e);
                    isResizing = true;
                    currentSidebar = rightSidebar;
                    document.body.style.cursor = 'ew-resize';
                    document.body.style.userSelect = 'none';
                    e.preventDefault();
                });
            } else {
                console.error('Right sidebar resizer not found! Resizer:', rightResizer, 'Sidebar:', rightSidebar);
            }
            
            // 마우스 이동 이벤트
            document.addEventListener('mousemove', (e) => {
                if (!isResizing || !currentSidebar) return;
                
                if (currentSidebar === leftSidebar) {
                    // 왼쪽 사이드바 리사이즈
                    const newWidth = e.clientX - 48; // 액티비티 바 폭 제외
                    if (newWidth >= 200 && newWidth <= 600) {
                        leftSidebar.style.width = newWidth + 'px';
                        console.log('Left sidebar resized to:', newWidth);
                        // 비디오 크기 업데이트 트리거
                        updateVideoSize();
                    }
                } else if (currentSidebar === rightSidebar) {
                    // 오른쪽 사이드바 리사이즈
                    const newWidth = window.innerWidth - e.clientX;
                    console.log('Right sidebar resize attempt:', {
                        'clientX': e.clientX,
                        'windowWidth': window.innerWidth,
                        'newWidth': newWidth,
                        'currentWidth': rightSidebar.style.width
                    });
                    if (newWidth >= 300 && newWidth <= 800) {
                        rightSidebar.style.width = newWidth + 'px';
                        console.log('Right sidebar successfully resized to:', newWidth);
                        // 비디오 크기 업데이트 트리거
                        updateVideoSize();
                    } else {
                        console.log('Right sidebar resize rejected - out of bounds:', newWidth);
                    }
                }
            });
            
            // 마우스 업 이벤트
            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    console.log('Resize ended');
                    isResizing = false;
                    currentSidebar = null;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                }
            });
        }
        
        // 비디오 크기 업데이트 함수
        function updateVideoSize() {
            const videoPlayer = document.getElementById('videoPlayer');
            if (videoPlayer && videoPlayer.style.display !== 'none') {
                // 강제로 비디오 크기 재계산
                videoPlayer.style.width = '100%';
                videoPlayer.style.maxWidth = '100%';
                
                // 무한 루프 방지: resize 이벤트 트리거 제거
                // 비디오 크기 조정만으로 충분함
            }
        }
        
        
        function showUploadSection() {
            // 업로드 섹션 표시
            document.getElementById('uploadSection').style.display = 'block';
            
            // 처리 옵션, 검색 섹션, 자막 생성 메뉴 숨기기
            document.getElementById('processingOptions').style.display = 'none';
            document.getElementById('searchSection').style.display = 'none';
            
            // 미디어 플레이어 숨기기
            document.querySelector('.media-player').style.display = 'none';
            
            // 문장 목록 숨기기
            document.getElementById('sentenceList').innerHTML = '';
            document.getElementById('bookmarkedList').innerHTML = '<p style="color: #858585;">북마크된 문장이 없습니다.</p>';
            
            // 미디어 선택 해제
            document.querySelectorAll('.media-item').forEach(item => {
                item.classList.remove('active');
            });
            
            currentMedia = null;
            console.log('Upload section shown');
        }
        
        function showWhisperOptions() {
            // Whisper 모달 띄우기
            document.getElementById('whisperModal').style.display = 'block';
        }
        
        function showSrtUpload() {
            // SRT 업로드 모달 띄우기
            document.getElementById('srtModal').style.display = 'block';
        }
        
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }
        
        function startModalWhisper() {
            // 현재 선택된 미디어가 있는지 확인
            if (!currentMedia) {
                const statusEl = document.getElementById('generationStatus');
                statusEl.style.display = 'block';
                statusEl.innerHTML = '❌ 미디어가 선택되지 않았습니다.';
                return;
            }
            
            // 모달에서 선택된 값들 가져오기
            const model = document.getElementById('modalModelSelect').value;
            const template = document.getElementById('modalTemplateSelect').value;
            
            // uploadedMediaId 설정
            uploadedMediaId = currentMedia;
            
            // 기존 프로세싱 옵션의 select 값들 설정
            document.getElementById('modelSelect').value = model;
            document.getElementById('templateSelect').value = template;
            
            // 모달 닫기
            closeModal('whisperModal');
            
            // 자막 생성 상태 표시
            const statusEl = document.getElementById('generationStatus');
            statusEl.style.display = 'block';
            statusEl.innerHTML = `🎤 Whisper 자막 생성 중... (모델: ${model})`;
            
            // 기존 Whisper 처리 함수 호출
            processWithWhisper();
        }
        
        function startModalSrtUpload() {
            // 현재 선택된 미디어가 있는지 확인
            if (!currentMedia) {
                const statusEl = document.getElementById('generationStatus');
                statusEl.style.display = 'block';
                statusEl.innerHTML = '❌ 미디어가 선택되지 않았습니다.';
                return;
            }
            
            // 모달에서 선택된 파일 가져오기
            const fileInput = document.getElementById('modalSrtFileInput');
            if (!fileInput.files || fileInput.files.length === 0) {
                const statusEl = document.getElementById('generationStatus');
                statusEl.style.display = 'block';
                statusEl.innerHTML = '❌ SRT 파일을 선택해주세요.';
                return;
            }
            
            // uploadedMediaId 설정
            uploadedMediaId = currentMedia;
            
            // 기존 SRT 파일 input에 파일 설정
            const originalFileInput = document.getElementById('srtFileInput');
            originalFileInput.files = fileInput.files;
            
            // 모달 닫기
            closeModal('srtModal');
            
            // 자막 생성 상태 표시
            const statusEl = document.getElementById('generationStatus');
            statusEl.style.display = 'block';
            statusEl.innerHTML = `📄 SRT 파일 업로드 중...`;
            
            // 기존 SRT 업로드 함수 호출
            uploadSentences();
        }
        
        // 비디오 자막 업데이트 함수
        function updateVideoSubtitles() {
            const videoSubtitlesDiv = document.getElementById('videoSubtitles');
            const currentSubtitleDiv = document.getElementById('currentSubtitle');
            
            if (videoPlayer.style.display === 'none' || !sentences || sentences.length === 0) {
                return;
            }
            
            const currentTime = videoPlayer.currentTime;
            const previousSubtitleDiv = document.getElementById('previousSubtitle');
            const currentSubtitleKoreanDiv = document.getElementById('currentSubtitleKorean');
            const nextSubtitleDiv = document.getElementById('nextSubtitle');
            let currentIndex = -1;
            
            // 현재 시간에 해당하는 문장 인덱스 찾기
            for (let i = 0; i < sentences.length; i++) {
                if (currentTime >= sentences[i].startTime && currentTime <= sentences[i].endTime) {
                    currentIndex = i;
                    currentSubtitleSentence = sentences[i];
                    break;
                }
            }
            
            if (currentIndex >= 0 && subtitleDisplayVisible) {
                
                // 이전 자막
                if (currentIndex > 0) {
                    previousSubtitleDiv.innerHTML = formatSpeakerText(sentences[currentIndex - 1].english, sentences[currentIndex - 1].id);
                    previousSubtitleDiv.style.display = 'block';
                } else {
                    previousSubtitleDiv.style.display = 'none';
                }
                
                // 현재 자막
                const currentSentence = sentences[currentIndex];
                currentSubtitleDiv.innerHTML = formatSpeakerText(currentSentence.english, currentSentence.id);
                
                // 동사 하이라이트를 나중에 적용 (비동기로)
                if (highlightVerbs) {
                    applyVerbHighlightToElement(currentSubtitleDiv, currentSentence.english, currentSentence.id);
                }
                
                // 현재 자막 번역
                if (currentSentence.korean && currentSentence.korean.trim() !== '') {
                    currentSubtitleKoreanDiv.innerHTML = formatSpeakerText(currentSentence.korean);
                    currentSubtitleKoreanDiv.style.display = 'block';
                } else {
                    currentSubtitleKoreanDiv.style.display = 'none';
                }
                
                // 다음 자막
                if (currentIndex < sentences.length - 1) {
                    nextSubtitleDiv.innerHTML = formatSpeakerText(sentences[currentIndex + 1].english, sentences[currentIndex + 1].id);
                    nextSubtitleDiv.style.display = 'block';
                } else {
                    nextSubtitleDiv.style.display = 'none';
                }
                
                // 오른쪽 사이드바 자동 스크롤 및 하이라이트
                updateSidebarHighlight(currentIndex);
                
                // 오버레이 자막 업데이트
                updateOverlaySubtitles(currentSentence);
                
                // 북마크 버튼 업데이트
                updateSubtitleBookmarkButton();
            } else {
                // 재생 중인 자막이 없을 때 모든 자막 숨김
                if (previousSubtitleDiv) previousSubtitleDiv.style.display = 'none';
                currentSubtitleDiv.innerHTML = '';
                if (currentSubtitleKoreanDiv) currentSubtitleKoreanDiv.style.display = 'none';
                if (nextSubtitleDiv) nextSubtitleDiv.style.display = 'none';
                currentSubtitleSentence = null;
                
                // 오버레이 자막도 숨김
                updateOverlaySubtitles(null);
            }
        }
        
        // 오디오 자막 업데이트 함수
        function updateAudioSubtitles() {
            const videoSubtitlesDiv = document.getElementById('videoSubtitles');
            const currentSubtitleDiv = document.getElementById('currentSubtitle');
            
            if (audioPlayer.style.display === 'none' || !sentences || sentences.length === 0) {
                return;
            }
            
            const currentTime = audioPlayer.currentTime;
            const previousSubtitleDiv = document.getElementById('previousSubtitle');
            const currentSubtitleKoreanDiv = document.getElementById('currentSubtitleKorean');
            const nextSubtitleDiv = document.getElementById('nextSubtitle');
            let currentIndex = -1;
            
            // 현재 시간에 해당하는 문장 인덱스 찾기
            for (let i = 0; i < sentences.length; i++) {
                if (currentTime >= sentences[i].startTime && currentTime <= sentences[i].endTime) {
                    currentIndex = i;
                    currentSubtitleSentence = sentences[i];
                    break;
                }
            }
            
            if (currentIndex >= 0 && subtitleDisplayVisible) {
                
                // 이전 자막
                if (currentIndex > 0) {
                    previousSubtitleDiv.innerHTML = formatSpeakerText(sentences[currentIndex - 1].english, sentences[currentIndex - 1].id);
                    previousSubtitleDiv.style.display = 'block';
                } else {
                    previousSubtitleDiv.style.display = 'none';
                }
                
                // 현재 자막
                const currentSentence = sentences[currentIndex];
                currentSubtitleDiv.innerHTML = formatSpeakerText(currentSentence.english, currentSentence.id);
                
                // 동사 하이라이트를 나중에 적용 (비동기로)
                if (highlightVerbs) {
                    applyVerbHighlightToElement(currentSubtitleDiv, currentSentence.english, currentSentence.id);
                }
                
                // 현재 자막 번역
                if (currentSentence.korean && currentSentence.korean.trim() !== '') {
                    currentSubtitleKoreanDiv.innerHTML = formatSpeakerText(currentSentence.korean);
                    currentSubtitleKoreanDiv.style.display = 'block';
                } else {
                    currentSubtitleKoreanDiv.style.display = 'none';
                }
                
                // 다음 자막
                if (currentIndex < sentences.length - 1) {
                    nextSubtitleDiv.innerHTML = formatSpeakerText(sentences[currentIndex + 1].english, sentences[currentIndex + 1].id);
                    nextSubtitleDiv.style.display = 'block';
                } else {
                    nextSubtitleDiv.style.display = 'none';
                }
                
                // 오른쪽 사이드바 자동 스크롤 및 하이라이트
                updateSidebarHighlight(currentIndex);
                
                // 오버레이 자막 업데이트
                updateOverlaySubtitles(currentSentence);
                
                // 북마크 버튼 업데이트
                updateSubtitleBookmarkButton();
            } else {
                // 재생 중인 자막이 없을 때 모든 자막 숨김
                if (previousSubtitleDiv) previousSubtitleDiv.style.display = 'none';
                currentSubtitleDiv.innerHTML = '';
                if (currentSubtitleKoreanDiv) currentSubtitleKoreanDiv.style.display = 'none';
                if (nextSubtitleDiv) nextSubtitleDiv.style.display = 'none';
                currentSubtitleSentence = null;
                
                // 오버레이 자막도 숨김
                updateOverlaySubtitles(null);
            }
        }
        
        // 사이드바 하이라이트 및 자동 스크롤 함수
        function updateSidebarHighlight(currentIndex) {
            // 이전에 재생 중이던 문장과 같으면 스크롤 안 함 (성능 최적화)
            if (window.lastHighlightedIndex === currentIndex) {
                return;
            }
            window.lastHighlightedIndex = currentIndex;
            
            // 모든 문장에서 playing 클래스 제거
            document.querySelectorAll('.sentence-item').forEach(item => {
                item.classList.remove('playing');
            });
            
            // 현재 재생 중인 문장에 playing 클래스 추가 및 스크롤
            const currentSentenceEl = document.querySelector(`[data-index="${currentIndex}"]`);
            if (currentSentenceEl) {
                currentSentenceEl.classList.add('playing');
                
                // 부드러운 스크롤로 현재 문장을 화면 중앙으로 이동
                currentSentenceEl.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center' 
                });
            }
        }
        
        // 오버레이 자막 업데이트 함수
        function updateOverlaySubtitles(currentSentence) {
            if (!overlaySubtitlesVisible) {
                return;
            }
            
            const overlaySubtitle = document.getElementById('videoOverlaySubtitles');
            
            if (currentSentence) {
                let subtitleText = '';
                
                // 언어 선택에 따른 텍스트 설정 (동기 처리)
                switch(subtitleLanguage) {
                    case 'english':
                        subtitleText = formatSpeakerText(currentSentence.english || '', currentSentence.id);
                        break;
                    case 'korean':
                        subtitleText = formatSpeakerText(currentSentence.korean || '');
                        break;
                    case 'both':
                        const englishText = formatSpeakerText(currentSentence.english || '', currentSentence.id);
                        const koreanText = currentSentence.korean ? 
                            formatSpeakerText(currentSentence.korean) : '';
                        if (englishText && koreanText) {
                            subtitleText = englishText + '<br><br>' + koreanText;
                        } else {
                            subtitleText = englishText || koreanText;
                        }
                        break;
                }
                
                overlaySubtitle.innerHTML = subtitleText;
                overlaySubtitle.style.display = 'block';
                
                // 동사 하이라이트를 나중에 적용 (비동기로)
                if (highlightVerbs && subtitleLanguage !== 'korean') {
                    applyVerbHighlightToElement(overlaySubtitle, currentSentence.english, currentSentence.id);
                }
            } else {
                overlaySubtitle.style.display = 'none';
            }
        }
        
        // 오버레이 자막 상태 변수 (항상 표시)
        let overlaySubtitlesVisible = true;
        
        // 오버레이 자막 설정 변수
        let overlayFontSizeScale = 1.2; // 기본 크기 (120%)
        let overlayPosition = 'center'; // 기본 위치 (중앙)
        let subtitleLanguage = 'english'; // 기본 언어 (영어만)
        let highlightVerbs = true; // 동사 하이라이트 기본값
        let verbHighlightMode = 'highlight'; // 'highlight' or 'blank'
        let verbCache = new Map(); // 동사 감지 결과 캐시
        let showBlanks = true; // 빈칸 표시 여부 (C키로 토글)
        
        // spaCy API를 통한 정확한 동사 감지 (DB 캐시 우선)
        async function detectVerbs(text, sentenceId = null) {
            if (!text) return [];
            
            // 로컬 캐시 확인
            if (verbCache.has(text)) {
                return verbCache.get(text);
            }
            
            try {
                const requestBody = { text: text };
                if (sentenceId) {
                    requestBody.sentence_id = sentenceId;
                }
                
                const response = await fetch('/api/detect-verbs', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });
                
                const data = await response.json();
                const verbs = data.verbs || [];
                
                // 캐시에 저장 (DB 캐시든 실시간이든)
                verbCache.set(text, verbs);
                
                if (data.cached) {
                    console.log('Using cached verbs from DB:', verbs);
                } else {
                    console.log('Real-time verb analysis:', verbs);
                }
                
                return verbs;
            } catch (error) {
                console.warn('spaCy API 호출 실패, 폴백 사용:', error);
                
                // 폴백: 간단한 패턴 매칭
                const fallbackVerbs = _detectVerbsFallback(text);
                verbCache.set(text, fallbackVerbs);
                return fallbackVerbs;
            }
        }
        
        // 폴백 동사 감지 (API 실패시)
        function _detectVerbsFallback(text) {
            const commonVerbs = ['am', 'is', 'are', 'was', 'were', 'have', 'has', 'had', 'do', 'does', 'did', 
                               'go', 'went', 'come', 'came', 'get', 'got', 'make', 'made', 'take', 'took', 
                               'work', 'works', 'play', 'plays', 'run', 'runs', 'walk', 'walks', 'talk', 'talks'];
            
            const words = text.toLowerCase().match(/\b\w+\b/g) || [];
            const found = words.filter(word => commonVerbs.includes(word));
            
            return [...new Set(found)].slice(0, 3);
        }
        
        // 동사 하이라이트 적용 함수 (비동기)
        async function applyVerbHighlight(text, sentenceId = null) {
            if (!text || !highlightVerbs) return text;
            
            const verbs = await detectVerbs(text, sentenceId);
            let processedText = text;
            
            verbs.forEach(verb => {
                const regex = new RegExp(`\\b(${verb})\\b`, 'gi');
                
                if (verbHighlightMode === 'highlight') {
                    // 단순 컬러 변경 (배경 제거)
                    processedText = processedText.replace(regex, 
                        '<span style="color: #ff6b35; font-weight: 600;">$1</span>'
                    );
                } else if (verbHighlightMode === 'blank') {
                    if (showBlanks) {
                        // 빈칸으로 대체 (흰색 밑줄)
                        processedText = processedText.replace(regex, 
                            '<span style="color: #ffffff; border-bottom: 1px solid #ffffff; display: inline-block; min-width: ' + (verb.length * 8) + 'px; text-align: center;">____</span>'
                        );
                    } else {
                        // 빈칸 숨김 (원래 단어 표시하지만 투명하게)
                        processedText = processedText.replace(regex, 
                            '<span style="color: transparent; background: none;">$1</span>'
                        );
                    }
                }
            });
            
            return processedText;
        }
        
        // 동사 하이라이트 토글 함수
        function toggleVerbHighlight() {
            highlightVerbs = !highlightVerbs;
            updateVerbHighlightButton();
            updateCurrentSubtitles();
        }
        
        // 동사 하이라이트 모드 전환 함수
        function toggleVerbMode() {
            verbHighlightMode = verbHighlightMode === 'highlight' ? 'blank' : 'highlight';
            updateVerbModeButton();
            updateCurrentSubtitles();
        }
        
        // 버튼 스타일 업데이트
        function updateVerbHighlightButton() {
            const btn = document.getElementById('verbHighlightBtn');
            if (highlightVerbs) {
                btn.innerHTML = '💛ON';
                btn.style.background = '#ffeb3b';
                btn.style.borderColor = '#ffeb3b';
                btn.style.color = '#333';
            } else {
                btn.innerHTML = '⚪OFF';
                btn.style.background = '#333333';
                btn.style.borderColor = '#555555';
                btn.style.color = '#cccccc';
            }
        }
        
        function updateVerbModeButton() {
            const btn = document.getElementById('verbModeBtn');
            if (verbHighlightMode === 'highlight') {
                btn.innerHTML = '🔆';
                btn.title = '하이라이트 모드 (클릭하면 빈칸 모드)';
            } else {
                btn.innerHTML = '📝';
                btn.title = '빈칸 모드 (클릭하면 하이라이트 모드)';
            }
        }
        
        // 현재 자막 업데이트
        function updateCurrentSubtitles() {
            if (currentSubtitleSentence) {
                updateVideoSubtitles();
                updateOverlaySubtitles(currentSubtitleSentence);
            }
        }
        
        // 키보드 컨트롤 핸들러
        function handleKeyboardControls(event) {
            // 입력 필드에서 타이핑 중일 때는 키보드 컨트롤 무시
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.contentEditable === 'true') {
                return;
            }
            
            const player = currentPlayer;
            if (!player || !sentences || sentences.length === 0) {
                return;
            }
            
            switch(event.code) {
                case 'ArrowLeft':
                    event.preventDefault();
                    goToPreviousSubtitle();
                    break;
                    
                case 'ArrowRight':
                    event.preventDefault();
                    goToNextSubtitle();
                    break;
                    
                case 'Space':
                    event.preventDefault();
                    togglePlayPause();
                    break;
                    
                case 'ArrowUp':
                    event.preventDefault();
                    adjustVolume(0.1);
                    break;
                    
                case 'ArrowDown':
                    event.preventDefault();
                    adjustVolume(-0.1);
                    break;
                    
                case 'Enter':
                    event.preventDefault();
                    toggleCurrentSubtitleBookmark();
                    break;
                    
                case 'KeyC':
                    event.preventDefault();
                    toggleBlankVisibility();
                    break;
            }
        }
        
        // 이전 자막으로 이동
        function goToPreviousSubtitle() {
            if (!sentences || sentences.length === 0) return;
            
            let targetIndex = -1;
            
            if (currentSentenceIndex >= 0 && currentSentenceIndex > 0) {
                targetIndex = currentSentenceIndex - 1;
            } else {
                // 현재 재생 중인 자막을 찾아서 이전으로
                const currentTime = currentPlayer.currentTime;
                for (let i = sentences.length - 1; i >= 0; i--) {
                    if (currentTime >= sentences[i].startTime) {
                        targetIndex = Math.max(0, i - 1);
                        break;
                    }
                }
            }
            
            if (targetIndex >= 0) {
                playSentence(targetIndex);
            }
        }
        
        // 다음 자막으로 이동
        function goToNextSubtitle() {
            if (!sentences || sentences.length === 0) return;
            
            let targetIndex = -1;
            
            if (currentSentenceIndex >= 0 && currentSentenceIndex < sentences.length - 1) {
                targetIndex = currentSentenceIndex + 1;
            } else {
                // 현재 재생 중인 자막을 찾아서 다음으로
                const currentTime = currentPlayer.currentTime;
                for (let i = 0; i < sentences.length; i++) {
                    if (currentTime < sentences[i].endTime) {
                        targetIndex = Math.min(sentences.length - 1, i + 1);
                        break;
                    }
                }
            }
            
            if (targetIndex >= 0 && targetIndex < sentences.length) {
                playSentence(targetIndex);
            }
        }
        
        // 재생/일시정지 토글
        function togglePlayPause() {
            if (!currentPlayer) return;
            
            if (currentPlayer.paused) {
                currentPlayer.play().catch(error => {
                    console.error('Play error:', error);
                });
            } else {
                currentPlayer.pause();
            }
        }
        
        // 볼륨 조절
        function adjustVolume(delta) {
            if (!currentPlayer) return;
            
            const newVolume = Math.max(0, Math.min(1, currentPlayer.volume + delta));
            currentPlayer.volume = newVolume;
            
            // 볼륨 표시 (임시)
            showVolumeIndicator(Math.round(newVolume * 100));
        }
        
        // 볼륨 표시기
        function showVolumeIndicator(volumePercent) {
            // 기존 인디케이터 제거
            const existingIndicator = document.getElementById('volumeIndicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }
            
            // 새 볼륨 인디케이터 생성
            const indicator = document.createElement('div');
            indicator.id = 'volumeIndicator';
            indicator.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 10px 20px;
                border-radius: 5px;
                font-size: 18px;
                z-index: 10000;
                pointer-events: none;
            `;
            indicator.innerHTML = `🔊 볼륨: ${volumePercent}%`;
            
            document.body.appendChild(indicator);
            
            // 2초 후 제거
            setTimeout(() => {
                if (indicator.parentNode) {
                    indicator.remove();
                }
            }, 2000);
        }
        
        // 현재 자막 즐겨찾기 토글
        function toggleCurrentSubtitleBookmark() {
            if (currentSentenceIndex >= 0 && currentSentenceIndex < sentences.length) {
                toggleBookmark(currentSentenceIndex);
            }
        }
        
        // 빈칸 표시/숨김 토글 (C키)
        function toggleBlankVisibility() {
            showBlanks = !showBlanks;
            
            // 빈칸 상태 표시
            showBlankToggleIndicator(showBlanks);
            
            // 현재 표시된 자막들을 다시 업데이트
            updateCurrentSubtitles();
        }
        
        // 빈칸 토글 상태 표시기
        function showBlankToggleIndicator(isVisible) {
            // 기존 인디케이터 제거
            const existingIndicator = document.getElementById('blankToggleIndicator');
            if (existingIndicator) {
                existingIndicator.remove();
            }
            
            // 새 상태 인디케이터 생성
            const indicator = document.createElement('div');
            indicator.id = 'blankToggleIndicator';
            indicator.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 10px 20px;
                border-radius: 5px;
                font-size: 18px;
                z-index: 10000;
                pointer-events: none;
            `;
            indicator.innerHTML = isVisible ? '👁️ 빈칸 보이기' : '🙈 빈칸 숨기기';
            
            document.body.appendChild(indicator);
            
            // 2초 후 제거
            setTimeout(() => {
                if (indicator.parentNode) {
                    indicator.remove();
                }
            }, 2000);
        }
        
        // 화자 구분을 위한 텍스트 처리 함수 (동기)
        function formatSpeakerText(text, sentenceId = null) {
            if (!text) return '';
            // ' - ' 를 줄바꿈으로 변환 (화자 구분)
            let formattedText = text.replace(/\s*-\s*/g, '<br>');
            
            // 문법 패턴 하이라이트 먼저 적용
            if (grammarHighlightEnabled && sentenceId) {
                formattedText = applyGrammarHighlight(formattedText);
            }
            
            // 단어를 클릭 가능하게 만들기 (sentenceId가 있을 때만)
            if (sentenceId) {
                formattedText = makeWordsInteractive(formattedText, sentenceId, text);
            }
            
            return formattedText;
        }
        
        // 문법 패턴 하이라이트 적용
        function applyGrammarHighlight(text) {
            let highlightedText = text;
            
            // 1. 조건문 패턴 (if, unless, provided that 등)
            highlightedText = highlightedText.replace(
                /\b(if|unless|provided that|as long as|in case)\b/gi,
                '<span class="grammar-conditional">$1</span>'
            );
            
            // 2. 시간 표현 (when, while, before, after 등)
            highlightedText = highlightedText.replace(
                /\b(when|while|before|after|during|since|until|as soon as)\b/gi,
                '<span class="grammar-time">$1</span>'
            );
            
            // 3. 원인/결과 (because, so, therefore 등)
            highlightedText = highlightedText.replace(
                /\b(because|since|as|so|therefore|thus|consequently|as a result)\b/gi,
                '<span class="grammar-cause">$1</span>'
            );
            
            // 4. 대조/양보 (but, however, although 등)
            highlightedText = highlightedText.replace(
                /\b(but|however|although|though|despite|in spite of|nevertheless|nonetheless)\b/gi,
                '<span class="grammar-contrast">$1</span>'
            );
            
            // 5. 수동태 패턴 (be + past participle)
            highlightedText = highlightedText.replace(
                /\b(am|is|are|was|were|been|being)\s+([\w]+ed|[\w]+en)\b/gi,
                '<span class="grammar-passive">$1 $2</span>'
            );
            
            // 6. 완료시제 (have/has + past participle)
            highlightedText = highlightedText.replace(
                /\b(have|has|had)\s+([\w]+ed|[\w]+en)\b/gi,
                '<span class="grammar-perfect">$1 $2</span>'
            );
            
            // 7. 미래시제 (will, going to)
            highlightedText = highlightedText.replace(
                /\b(will|shall|going to)\s+(\w+)/gi,
                '<span class="grammar-future">$1 $2</span>'
            );
            
            // 8. 모달동사 (can, could, should 등)
            highlightedText = highlightedText.replace(
                /\b(can|could|should|would|might|may|must|ought to)\s+(\w+)/gi,
                '<span class="grammar-modal">$1 $2</span>'
            );
            
            return highlightedText;
        }
        
        // 단어 캐시 (북마크 기능용)
        let wordDefinitionCache = new Map(); // 단어 정보 캐시
        let difficultyHighlightEnabled = true; // 난이도 하이라이트 활성화
        let difficultyHighlightCache = new Map(); // 난이도 캐시
        let grammarHighlightEnabled = true; // 문법 패턴 하이라이트 활성화
        
        // 텍스트의 단어들을 인터랙티브하게 만들기
        function makeWordsInteractive(text, sentenceId, originalText) {
            // HTML 태그 내부는 건드리지 않고, 일반 텍스트만 처리
            return text.replace(/([^<>]+)(?=<|$)/g, function(match) {
                // 단어 단위로 분할하여 span으로 감싸기
                return match.replace(/\b([a-zA-Z]+(?:'[a-zA-Z]+)?)\b/g, function(word) {
                    const wordLower = word.toLowerCase();
                    
                    // 일단 기본 클래스로 span 생성
                    const spanHtml = `<span class="interactive-word" 
                                  data-word="${wordLower}" 
                                  data-sentence-id="${sentenceId}"
                                  data-context="${originalText}"
                                  onclick="bookmarkWord(this)">
                                ${word}
                            </span>`;
                    
                    // 난이도 클래스를 비동기로 적용
                    if (difficultyHighlightEnabled) {
                        setTimeout(async () => {
                            try {
                                const difficultyClass = await getDifficultyClass(wordLower);
                                if (difficultyClass) {
                                    // 같은 단어의 모든 인스턴스에 클래스 적용
                                    const elements = document.querySelectorAll(`[data-word="${wordLower}"]`);
                                    elements.forEach(el => el.classList.add(difficultyClass));
                                }
                            } catch (error) {
                                console.warn('Failed to apply difficulty class:', error);
                            }
                        }, 0);
                    }
                    
                    return spanHtml;
                });
            });
        }
        
        // 단어 난이도에 따른 CSS 클래스 반환
        async function getDifficultyClass(word) {
            // 캐시에서 확인
            if (difficultyHighlightCache.has(word)) {
                return difficultyHighlightCache.get(word);
            }
            
            try {
                // API를 통해 실제 CEFR 데이터 확인
                const response = await fetch(`/api/word/difficulty/${encodeURIComponent(word)}`);
                const data = await response.json();
                
                const className = data.difficulty === 'hard' ? 'difficulty-hard' : '';
                
                // 캐시에 저장
                difficultyHighlightCache.set(word, className);
                
                return className;
            } catch (error) {
                // API 오류 시 빈 클래스 반환
                console.warn('Difficulty API error:', error);
                difficultyHighlightCache.set(word, '');
                return '';
            }
        }
        
        
        
        // 단어 북마크 (클릭 시)
        async function bookmarkWord(element) {
            const word = element.dataset.word;
            const sentenceId = element.dataset.sentenceId;
            const context = element.dataset.context;
            
            console.log('Adding word to vocabulary:', word);
            
            // 시각적 피드백 - 로딩
            element.style.background = 'rgba(255, 193, 7, 0.3)';
            element.style.transition = 'all 0.3s ease';
            
            try {
                // 개인 단어장에 추가 (단순화된 버전)
                const addResponse = await fetch('/api/vocabulary/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        word: word,
                        context_sentence: context,
                        sentence_id: sentenceId
                    })
                });
                
                if (addResponse.ok) {
                    // 성공 피드백
                    element.style.background = 'rgba(76, 175, 80, 0.4)';
                    element.style.border = '1px solid #4CAF50';
                    element.classList.add('vocab-added');
                    
                    // 성공 메시지 표시
                    showVocabMessage('📚 단어장에 추가됨!', '#4CAF50');
                    
                    // 개인 단어장 통계 업데이트
                    updateVocabularyStats();
                    
                } else {
                    throw new Error('Failed to add word to vocabulary');
                }
                
            } catch (error) {
                console.error('Error adding word to vocabulary:', error);
                
                // 오류 피드백
                element.style.background = 'rgba(244, 67, 54, 0.3)';
                showVocabMessage('❌ 단어장 추가 실패', '#F44336');
            }
            
            // 2초 후 원래 스타일로 복원 (vocab-added 클래스는 유지)
            setTimeout(() => {
                if (!element.classList.contains('vocab-added')) {
                    element.style.background = '';
                    element.style.border = '';
                }
            }, 2000);
        }
        
        // 단어장 메시지 표시
        function showVocabMessage(message, color) {
            const existingMsg = document.getElementById('vocabMessage');
            if (existingMsg) {
                existingMsg.remove();
            }
            
            const messageDiv = document.createElement('div');
            messageDiv.id = 'vocabMessage';
            messageDiv.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${color};
                color: white;
                padding: 12px 20px;
                border-radius: 6px;
                font-size: 14px;
                z-index: 10002;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                animation: slideInRight 0.3s ease;
            `;
            messageDiv.textContent = message;
            
            document.body.appendChild(messageDiv);
            
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.style.animation = 'slideOutRight 0.3s ease';
                    setTimeout(() => messageDiv.remove(), 300);
                }
            }, 3000);
        }
        
        // 개인 단어장 통계 업데이트
        async function updateVocabularyStats() {
            try {
                const response = await fetch('/api/vocabulary/statistics');
                if (response.ok) {
                    const stats = await response.json();
                    
                    // 통계 표시 (필요시 UI 업데이트)
                    console.log('Vocabulary stats:', stats);
                    
                    // TODO: 통계를 UI에 표시하는 기능 구현
                }
            } catch (error) {
                console.error('Error updating vocabulary stats:', error);
            }
        }
        
        // 동사 하이라이트를 나중에 적용하는 함수
        async function applyVerbHighlightToElement(element, text, sentenceId = null) {
            if (!text || !highlightVerbs) return;
            
            try {
                const highlightedText = await applyVerbHighlight(text, sentenceId);
                if (element && element.innerHTML !== highlightedText) {
                    element.innerHTML = highlightedText;
                }
            } catch (error) {
                console.warn('Error applying verb highlight:', error);
            }
        }
        
        // 자막 언어 선택 함수
        function setSubtitleLanguage(language) {
            subtitleLanguage = language;
            
            // 버튼 스타일 업데이트
            const engBtn = document.getElementById('subtitleEngBtn');
            const korBtn = document.getElementById('subtitleKorBtn');
            const bothBtn = document.getElementById('subtitleBothBtn');
            
            // 모든 버튼 초기화
            [engBtn, korBtn, bothBtn].forEach(btn => {
                btn.style.background = '#333333';
                btn.style.color = '#cccccc';
                btn.style.borderColor = '#555555';
            });
            
            // 선택된 버튼 활성화
            let activeBtn;
            switch(language) {
                case 'english':
                    activeBtn = engBtn;
                    break;
                case 'korean':
                    activeBtn = korBtn;
                    break;
                case 'both':
                    activeBtn = bothBtn;
                    break;
            }
            
            if (activeBtn) {
                activeBtn.style.background = '#0e639c';
                activeBtn.style.color = '#ffffff';
                activeBtn.style.borderColor = '#0e639c';
            }
            
            // 현재 자막 업데이트
            if (currentSubtitleSentence) {
                updateVideoSubtitles();
                updateOverlaySubtitles(currentSubtitleSentence);
            }
        }
        
        // 오버레이 크기 조절 함수
        function adjustOverlaySize(delta) {
            overlayFontSizeScale += delta;
            
            // 최소 0.5 (50%), 최대 3.0 (300%)
            if (overlayFontSizeScale < 0.5) overlayFontSizeScale = 0.5;
            if (overlayFontSizeScale > 3.0) overlayFontSizeScale = 3.0;
            
            updateOverlayStyles();
        }
        
        // 오버레이 크기 초기화
        function resetOverlaySize() {
            overlayFontSizeScale = 1.2;
            updateOverlayStyles();
        }
        
        // 오버레이 위치 설정
        function setOverlayPosition(position) {
            overlayPosition = position;
            updateOverlayStyles();
            updatePositionButtons();
        }
        
        // 오버레이 스타일 업데이트
        function updateOverlayStyles() {
            const overlaySubtitle = document.getElementById('videoOverlaySubtitles');
            const sizeDisplay = document.getElementById('overlaySizeDisplay');
            
            // 기본 폰트 크기 3.5em에 스케일 적용
            const fontSize = 3.5 * overlayFontSizeScale;
            overlaySubtitle.style.fontSize = fontSize + 'em';
            
            // 위치 설정
            if (overlayPosition === 'center') {
                overlaySubtitle.style.top = '50%';
                overlaySubtitle.style.bottom = 'auto';
                overlaySubtitle.style.transform = 'translate(-50%, -50%)';
            } else { // bottom
                overlaySubtitle.style.top = 'auto';
                overlaySubtitle.style.bottom = '15%';
                overlaySubtitle.style.transform = 'translateX(-50%)';
            }
            
            // 크기 표시 업데이트
            const percentage = Math.round(overlayFontSizeScale * 100);
            sizeDisplay.textContent = percentage + '%';
        }
        
        // 위치 버튼 상태 업데이트
        function updatePositionButtons() {
            const centerBtn = document.getElementById('positionCenterBtn');
            const bottomBtn = document.getElementById('positionBottomBtn');
            
            if (overlayPosition === 'center') {
                centerBtn.style.background = '#0e639c';
                centerBtn.style.borderColor = '#0e639c';
                centerBtn.style.color = '#ffffff';
                
                bottomBtn.style.background = '#333333';
                bottomBtn.style.borderColor = '#555555';
                bottomBtn.style.color = '#cccccc';
            } else {
                centerBtn.style.background = '#333333';
                centerBtn.style.borderColor = '#555555';
                centerBtn.style.color = '#cccccc';
                
                bottomBtn.style.background = '#0e639c';
                bottomBtn.style.borderColor = '#0e639c';
                bottomBtn.style.color = '#ffffff';
            }
        }
        
        // 자막 표시 토글 함수
        function toggleSubtitleDisplay() {
            const videoSubtitlesDiv = document.getElementById('videoSubtitles');
            const toggleBtn = document.getElementById('subtitleToggleBtn');
            
            subtitleDisplayVisible = !subtitleDisplayVisible;
            
            if (subtitleDisplayVisible) {
                videoSubtitlesDiv.style.display = 'flex';
                toggleBtn.innerHTML = '🔽 숨기기';
            } else {
                videoSubtitlesDiv.style.display = 'none';
                toggleBtn.innerHTML = '🔼 보이기';
            }
        }
        
        // 자막 북마크 토글 함수
        function toggleSubtitleBookmark() {
            if (!currentSubtitleSentence) {
                console.log('No current subtitle sentence');
                return;
            }
            
            // 현재 자막 문장의 인덱스 찾기
            const sentenceIndex = sentences.findIndex(s => s.id === currentSubtitleSentence.id);
            if (sentenceIndex === -1) {
                console.log('Sentence not found in sentences array');
                return;
            }
            
            // 북마크 상태 토글
            const sentence = sentences[sentenceIndex];
            const newBookmarkState = !sentence.bookmark;
            
            console.log('Toggling bookmark for sentence:', sentence.id, 'to:', newBookmarkState);
            
            // 서버에 북마크 상태 업데이트
            fetch(`/api/media/${currentMedia}/sentences/${sentence.id}/bookmark`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ bookmark: newBookmarkState })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // 로컬 상태 업데이트
                    sentence.bookmark = newBookmarkState;
                    
                    // UI 업데이트
                    updateSubtitleBookmarkButton();
                    
                    // 문장 목록의 해당 항목도 업데이트
                    const sentenceElement = document.querySelector(`[data-index="${sentenceIndex}"]`);
                    if (sentenceElement) {
                        if (newBookmarkState) {
                            sentenceElement.classList.add('bookmarked');
                        } else {
                            sentenceElement.classList.remove('bookmarked');
                        }
                    }
                    
                    // 북마크 목록 업데이트
                    updateBookmarkedList();
                    
                    console.log('Bookmark updated successfully');
                } else {
                    console.error('Failed to update bookmark:', data.error);
                }
            })
            .catch(error => {
                console.error('Bookmark update error:', error);
            });
        }
        
        // 북마크 버튼 업데이트
        function updateSubtitleBookmarkButton() {
            const btn = document.getElementById('subtitleBookmarkBtn');
            if (!btn || !currentSubtitleSentence) return;
            
            const sentenceElement = document.querySelector(`[data-sentence-id="${currentSubtitleSentence.id}"]`);
            if (sentenceElement && sentenceElement.classList.contains('bookmarked')) {
                btn.innerHTML = '★';
                btn.style.background = '#ff9800';
                btn.style.color = '#ffffff';
            } else {
                btn.innerHTML = '☆';
                btn.style.background = '#333333';
                btn.style.color = '#cccccc';
            }
        }
        
        // 자막 삭제 함수
        function deleteSubtitles() {
            if (!currentMedia) {
                const statusEl = document.getElementById('generationStatus');
                statusEl.style.display = 'block';
                statusEl.innerHTML = '❌ 미디어가 선택되지 않았습니다.';
                return;
            }
            
            // 삭제 확인을 위해 버튼 텍스트 변경
            const deleteBtn = event.target;
            if (deleteBtn.textContent === '🗑️ 자막 삭제') {
                deleteBtn.textContent = '❗ 정말 삭제?';
                deleteBtn.style.background = '#ff4444';
                setTimeout(() => {
                    deleteBtn.textContent = '🗑️ 자막 삭제';
                    deleteBtn.style.background = '#d32f2f';
                }, 3000);
                return;
            }
            
            const statusEl = document.getElementById('generationStatus');
            statusEl.style.display = 'block';
            statusEl.innerHTML = '🗑️ 자막 삭제 중...';
            
            fetch(`/api/media/${currentMedia}/subtitles`, {
                method: 'DELETE'
            })
            .then(response => {
                if (!response.ok) {
                    return response.json().then(errorData => {
                        throw new Error(`Server error: ${errorData.error || response.statusText}`);
                    });
                }
                return response.json();
            })
            .then(data => {
                if (data.success) {
                    statusEl.innerHTML = '✅ 자막이 삭제되었습니다. 새로운 자막을 생성할 수 있습니다.';
                    
                    // 문장 목록 초기화
                    document.getElementById('sentenceList').innerHTML = '';
                    sentences = [];
                    
                    // 미디어 목록 새로고침
                    loadMediaList();
                    
                    // 5초 후 상태 메시지 숨기기
                    setTimeout(() => {
                        statusEl.style.display = 'none';
                    }, 5000);
                } else {
                    statusEl.innerHTML = `❌ 자막 삭제 실패: ${data.error}`;
                }
            })
            .catch(error => {
                console.error('Delete subtitles error:', error);
                statusEl.innerHTML = `❌ 자막 삭제 중 오류 발생: ${error.message}`;
            });
        }
        
        // 모달 외부 클릭 시 닫기
        window.onclick = function(event) {
            const whisperModal = document.getElementById('whisperModal');
            const srtModal = document.getElementById('srtModal');
            
            if (event.target == whisperModal) {
                whisperModal.style.display = 'none';
            }
            if (event.target == srtModal) {
                srtModal.style.display = 'none';
            }
        }
        
        function loadMediaSentences(mediaId) {
            console.log('loadMediaSentences called with mediaId:', mediaId);
            currentMedia = mediaId;
            
            // 업로드 섹션 숨기기
            document.getElementById('uploadSection').style.display = 'none';
            
            // 영상 재생화면이 항상 보이도록 설정 (자막 패널로 전환하지 않음)
            // showPanel('subtitle'); // 이 줄을 제거하여 현재 패널 유지
            
            // 미디어 플레이어와 자막 컨테이너가 보이도록 확인
            const mediaPlayerDiv = document.querySelector('.media-player');
            if (mediaPlayerDiv) {
                mediaPlayerDiv.style.display = 'block';
            }
            
            // 자막 컨테이너도 항상 보이도록 설정
            const videoSubtitlesContainer = document.getElementById('videoSubtitlesContainer');
            if (videoSubtitlesContainer) {
                videoSubtitlesContainer.style.display = 'block';
            }
            
            // 현재 선택된 미디어 강조
            document.querySelectorAll('.media-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.mediaId == mediaId) {
                    item.classList.add('active');
                }
            });
            
            // 미디어 정보 로드 (파일명 가져오기)
            fetch('/api/media')
                .then(response => response.json())
                .then(mediaList => {
                    const media = mediaList.find(m => m.id == mediaId);
                    if (media) {
                        // 플레이어에 파일 로드 (영상/오디오 구분)
                        const mediaTitle = document.getElementById('mediaTitle');
                        const mediaPlayerDiv = document.querySelector('.media-player');
                        
                        // 영상 파일 확인
                        const videoExtensions = ['mp4', 'avi', 'mov', 'mkv', 'webm', 'flv'];
                        const fileExt = media.filename.toLowerCase().split('.').pop();
                        const isVideoFile = videoExtensions.includes(fileExt);
                        
                        if (isVideoFile) {
                            // HTML5 비디오 플레이어 사용
                            const videoSrc = `/api/audio/${media.filename}`;
                            console.log('Loading video:', videoSrc);
                            
                            videoPlayer.src = videoSrc;
                            videoPlayer.load();
                            
                            document.getElementById('videoContainer').style.display = 'block';
                            audioPlayer.style.display = 'none';
                            document.getElementById('videoSubtitlesContainer').style.display = 'block';
                            currentPlayer = videoPlayer;
                            
                            // 비디오 로드 후 크기 업데이트
                            videoPlayer.addEventListener('loadedmetadata', updateVideoSize, { once: true });
                        } else {
                            // 오디오 플레이어 사용
                            audioPlayer.src = `/api/audio/${media.filename}`;
                            audioPlayer.style.display = 'block';
                            document.getElementById('videoContainer').style.display = 'none';  // .el() 제거
                            videoPlayer.src = '';  // 비디오 소스 제거
                            videoPlayer.load();     // 비디오 플레이어 리셋
                            document.getElementById('videoSubtitlesContainer').style.display = 'block';  // 오디오에도 자막 표시
                            currentPlayer = audioPlayer;
                        }
                        
                        mediaTitle.textContent = media.filename;
                        mediaPlayerDiv.style.display = 'block';
                        
                        // 미디어 상태에 따라 처리 옵션 표시 여부 결정
                        const processingOptions = document.getElementById('processingOptions');
                        
                        if (media.status === 'uploaded' || media.status === 'error' || (isVideoFile && media.status === 'completed')) {
                            // 처리되지 않은 미디어 또는 영상 파일은 처리 옵션 표시
                            processingOptions.style.display = 'block';
                            uploadedMediaId = media.id; // 전역 변수 설정
                        } else {
                            // 이미 처리된 오디오 파일은 처리 옵션 숨김
                            processingOptions.style.display = 'none';
                        }
                        
                        console.log(`Loaded audio: ${media.filename}, status: ${media.status}`);
                    }
                })
                .catch(error => {
                    console.error('Failed to load media info:', error);
                });
            
            // 챕터 구조 로드
            fetch(`/api/media/${mediaId}/chapters`)
                .then(response => response.json())
                .then(chapters => {
                    displayChapters(chapters);
                })
                .catch(error => {
                    console.error('Failed to load chapters:', error);
                });
            
            // 그룹화된 문장 로드
            console.log('Fetching grouped sentences for mediaId:', mediaId);
            fetch(`/api/media/${mediaId}/sentences-grouped`)
                .then(response => {
                    console.log('Sentences API response status:', response.status);
                    return response.json();
                })
                .then(chapters => {
                    console.log('Received chapters data:', chapters);
                    displayGroupedSentences(chapters);
                    console.log(`Loaded ${chapters.length} chapters with scenes and sentences`);
                })
                .catch(error => {
                    console.error('Failed to load grouped sentences:', error);
                });
            
            // 번역 상태 확인
            checkTranslationStatus();
            
            // 백그라운드에서 동사 분석 시작
            startVerbAnalysis(mediaId);
            
            // 오른쪽 사이드바 표시 (문장 목록이 있는 경우)
            const rightSidebar = document.getElementById('rightSidebar');
            if (rightSidebar.classList.contains('collapsed')) {
                toggleRightSidebar();
            }
        }
        
        // 백그라운드 동사 분석 시작
        function startVerbAnalysis(mediaId) {
            console.log('Starting background verb analysis for media:', mediaId);
            
            fetch(`/api/media/${mediaId}/analyze-verbs`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                }
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log('✓ Background verb analysis started:', data.message);
                } else {
                    console.warn('Failed to start verb analysis:', data.error);
                }
            })
            .catch(error => {
                console.warn('Error starting verb analysis:', error);
            });
        }
        
        function loadGroupedSentences(mediaId) {
            // 그룹화된 문장 로드
            fetch(`/api/media/${mediaId}/sentences-grouped`)
                .then(response => response.json())
                .then(chapters => {
                    displayGroupedSentences(chapters);
                    console.log(`Loaded ${chapters.length} chapters with scenes and sentences`);
                })
                .catch(error => {
                    console.error('Failed to load grouped sentences:', error);
                });
        }
        
        function displayChapters(chapters) {
            const chapterListEl = document.getElementById('chapterList');
            const chapterContentEl = document.getElementById('chapterContent');
            
            if (chapters.length === 0) {
                chapterListEl.style.display = 'none';
                return;
            }
            
            chapterListEl.style.display = 'block';
            
            let html = '';
            chapters.forEach(chapter => {
                html += `<div class="chapter-item">
                    <strong>${chapter.title}</strong> (${chapter.startTime.toFixed(1)}s - ${chapter.endTime.toFixed(1)}s)
                    <div>${chapter.scene_count}개 씬</div>
                `;
                
                chapter.scenes.forEach(scene => {
                    html += `<div class="scene-item">
                        ${scene.title} (${scene.sentence_count}개 문장)
                    </div>`;
                });
                
                html += '</div>';
            });
            
            chapterContentEl.innerHTML = html;
        }
        
        function loadSimulationData() {
            // 시뮬레이션 데이터
            sentences = [
                {
                    id: 1,
                    english: "What are you doing?",
                    korean: "뭐 하고 있어?",
                    start_time: 0,
                    end_time: 2,
                    bookmark: false
                },
                {
                    id: 2,
                    english: "I'm learning English with this amazing tool.",
                    korean: "이 멋진 도구로 영어를 공부하고 있어요.",
                    start_time: 2,
                    end_time: 5,
                    bookmark: false
                },
                {
                    id: 3,
                    english: "Can you help me with my pronunciation?",
                    korean: "발음 도와줄 수 있어?",
                    start_time: 5,
                    end_time: 8,
                    bookmark: false
                }
            ];
            
            displaySentences();
        }
        
        function generateSentences() {
            // 실제로는 Whisper API 호출
            loadSimulationData();
        }
        
        function displayGroupedSentences(chapters) {
            const listEl = document.getElementById('sentenceList');
            if (!listEl) {
                console.error('sentenceList element not found!');
                return;
            }
            
            listEl.innerHTML = '';
            
            // 전역 sentences 배열 초기화
            sentences = [];
            let globalIndex = 0;
            
            console.log('displayGroupedSentences called with:', chapters);
            console.log('sentenceList element:', listEl);

            chapters.forEach((chapter, chapterIndex) => {
                // 챕터 섹션 생성
                const chapterSection = document.createElement('div');
                chapterSection.className = 'chapter-section';
                chapterSection.dataset.chapterId = chapter.id;
                
                // 챕터 헤더
                const chapterHeader = document.createElement('div');
                chapterHeader.className = 'chapter-header';
                chapterHeader.innerHTML = `
                    <div>
                        <div class="chapter-title">📚 ${chapter.title}</div>
                        <div class="chapter-info">${chapter.startTime?.toFixed(1) || 0}s - ${chapter.endTime?.toFixed(1) || 0}s</div>
                    </div>
                    <div class="chapter-info">
                        ${chapter.scenes?.length || 0}개 씬
                        <button class="chapter-extract-btn" onclick="extractChapter(${chapter.id}, event)">MP3</button>
                        <button class="chapter-extract-btn" onclick="extractChapterMP4(${chapter.id}, event)" style="background: #2563eb;">MP4</button>
                        <span class="collapse-icon">▼</span>
                    </div>
                `;
                
                // 챕터 접기/펼치기
                chapterHeader.onclick = function(e) {
                    // MP3 추출 버튼을 클릭한 경우 무시
                    if (e.target.classList.contains('chapter-extract-btn')) {
                        return;
                    }
                    
                    const content = chapterSection.querySelector('.chapter-content');
                    const icon = chapterHeader.querySelector('.collapse-icon');
                    if (content.style.display === 'none') {
                        content.style.display = 'block';
                        icon.textContent = '▼';
                        chapterSection.classList.remove('collapsed');
                    } else {
                        content.style.display = 'none';
                        icon.textContent = '▶';
                        chapterSection.classList.add('collapsed');
                    }
                };
                
                chapterSection.appendChild(chapterHeader);
                
                // 챕터 내용
                const chapterContent = document.createElement('div');
                chapterContent.className = 'chapter-content';
                
                // 씬들 처리
                chapter.scenes?.forEach((scene, sceneIndex) => {
                    const sceneStartIndex = globalIndex; // 이 씬의 시작 인덱스 저장
                    
                    const sceneSection = document.createElement('div');
                    sceneSection.className = 'scene-section';
                    sceneSection.dataset.sceneId = scene.id;
                    
                    // 씬 헤더
                    const sceneHeader = document.createElement('div');
                    sceneHeader.className = 'scene-header';
                    sceneHeader.innerHTML = `
                        <div>
                            <div class="scene-title">🎬 ${scene.title}</div>
                            <div class="scene-info">${scene.startTime?.toFixed(1) || 0}s - ${scene.endTime?.toFixed(1) || 0}s</div>
                        </div>
                        <div class="scene-info">
                            ${scene.sentences?.length || 0}개 문장
                            <button class="scene-extract-btn" onclick="extractScene(${scene.id}, event)">MP3</button>
                            <button class="scene-extract-btn" onclick="extractSceneMP4(${scene.id}, event)" style="background: #2563eb;">MP4</button>
                            <span class="collapse-icon">▼</span>
                        </div>
                    `;
                    
                    // 씬 접기/펼치기 및 씬으로 이동
                    sceneHeader.onclick = function(e) {
                        // MP3 추출 버튼을 클릭한 경우 무시
                        if (e.target.classList.contains('scene-extract-btn')) {
                            return;
                        }
                        
                        // 접기/펼치기 아이콘을 클릭한 경우
                        if (e.target.classList.contains('collapse-icon') || e.target.closest('.collapse-icon')) {
                            const content = sceneSection.querySelector('.scene-content');
                            const icon = sceneHeader.querySelector('.collapse-icon');
                            if (content.style.display === 'none') {
                                content.style.display = 'block';
                                icon.textContent = '▼';
                                sceneSection.classList.remove('collapsed');
                            } else {
                                content.style.display = 'none';
                                icon.textContent = '▶';
                                sceneSection.classList.add('collapsed');
                            }
                        } else {
                            // 씬 제목을 클릭한 경우 - 해당 씬으로 이동
                            jumpToScene(scene, sceneStartIndex);
                        }
                    };
                    
                    sceneSection.appendChild(sceneHeader);
                    
                    // 씬 내용 (문장들)
                    const sceneContent = document.createElement('div');
                    sceneContent.className = 'scene-content';
                    
                    scene.sentences?.forEach((sentence, sentenceIndex) => {
                        // 문장 데이터 정규화 (startTime/endTime 필드 통일)
                        const normalizedSentence = {
                            ...sentence,
                            startTime: sentence.startTime || sentence.start_time || 0,
                            endTime: sentence.endTime || sentence.end_time || 0
                        };
                        
                        // 전역 sentences 배열에 추가
                        sentences.push(normalizedSentence);
                        
                        const sentenceEl = document.createElement('div');
                        sentenceEl.className = 'sentence-item' + (sentence.bookmark ? ' bookmarked' : '');
                        sentenceEl.dataset.index = globalIndex;
                        sentenceEl.dataset.sentenceId = sentence.id;
                        
                        sentenceEl.innerHTML = `
                            <span class="sentence-number">${sentence.order}.</span>
                            <span class="sentence-text">${formatSpeakerText(sentence.english, sentence.id)}</span>
                            <span class="sentence-korean">${formatSpeakerText(sentence.korean || '')}</span>
                            <div style="font-size: 0.7em; color: #666; margin-top: 3px;">
                                ${sentence.startTime?.toFixed(1) || 0}s - ${sentence.endTime?.toFixed(1) || 0}s
                            </div>
                            <button class="bookmark-btn" onclick="toggleBookmark(${globalIndex}, event)">★</button>
                            <button class="extract-btn" onclick="extractMP3(${globalIndex}, event)">MP3</button>
                            <button class="extract-btn" onclick="extractMP4(${globalIndex}, event)" style="background: #2563eb;">MP4</button>
                        `;

                        sentenceEl.onclick = (function(index, sentenceData) {
                            return function(e) {
                                if (!e.target.classList.contains('bookmark-btn') && 
                                    !e.target.classList.contains('extract-btn')) {
                                    console.log('Sentence clicked:', index, sentenceData.english);
                                    playSentence(index);
                                }
                            };
                        })(globalIndex, normalizedSentence);
                        
                        // 호버 효과 개선
                        sentenceEl.addEventListener('mouseenter', function() {
                            this.style.cursor = 'pointer';
                        });

                        sceneContent.appendChild(sentenceEl);
                        globalIndex++;
                    });
                    
                    sceneSection.appendChild(sceneContent);
                    chapterContent.appendChild(sceneSection);
                });
                
                chapterSection.appendChild(chapterContent);
                listEl.appendChild(chapterSection);
            });

            console.log(`Loaded ${sentences.length} sentences`);
            updateBookmarkedList();
        }
        
        function displaySentences() {
            const listEl = document.getElementById('sentenceList');
            listEl.innerHTML = '';
            
            sentences.forEach((sentence, index) => {
                const el = document.createElement('div');
                el.className = 'sentence-item' + (sentence.bookmark ? ' bookmarked' : '');
                el.dataset.index = index;
                
                el.innerHTML = `
                    <span class="sentence-number">${sentence.id || sentence.order}.</span>
                    <span class="sentence-text">${sentence.english}</span>
                    <span class="sentence-korean">${sentence.korean || ''}</span>
                    <div style="font-size: 0.7em; color: #666; margin-top: 3px;">
                        ${sentence.chapter_title || ''} > ${sentence.scene_title || ''} 
                        (${sentence.startTime?.toFixed(1) || 0}s - ${sentence.endTime?.toFixed(1) || 0}s)
                    </div>
                    <button class="bookmark-btn" onclick="toggleBookmark(${index}, event)">★</button>
                    <button class="extract-btn" onclick="extractMP3(${index}, event)">MP3</button>
                    <button class="extract-btn" onclick="extractMP4(${index}, event)" style="background: #2563eb;">MP4</button>
                `;
                
                el.onclick = function(e) {
                    if (!e.target.classList.contains('bookmark-btn') && 
                        !e.target.classList.contains('extract-btn')) {
                        playSentence(index);
                    }
                };
                
                listEl.appendChild(el);
            });
            
            updateBookmarkedList();
        }
        
        function playSentence(index) {
            const sentence = sentences[index];
            console.log('playSentence called:', index, sentence);
            
            if (currentPlayer && sentence) {
                const startTime = sentence.startTime || sentence.start_time || 0;
                
                console.log('Playing sequentially from sentence:', index, 'start time:', startTime);
                
                // HTML5 플레이어 (비디오/오디오 공통)
                currentPlayer.currentTime = startTime;
                currentPlayer.play().then(() => {
                    console.log('Media started playing sequentially from sentence', index);
                }).catch(error => {
                    console.error('Media play error:', error);
                });
                
                currentSentenceIndex = index;
                
                // 현재 재생 중인 문장 강조 및 스크롤
                updateSidebarHighlight(index);
            } else {
                console.error('Cannot play:', {currentPlayer, sentence});
            }
        }
        
        function jumpToScene(scene, startingIndex) {
            console.log('jumpToScene called:', scene.title, startingIndex);
            
            if (!scene.sentences || scene.sentences.length === 0) {
                console.log('No sentences in scene');
                return;
            }
            
            // 해당 씬의 첫 번째 문장으로 스크롤
            const firstSentenceEl = document.querySelector(`[data-index="${startingIndex}"]`);
            if (firstSentenceEl) {
                firstSentenceEl.scrollIntoView({ 
                    behavior: 'smooth', 
                    block: 'center' 
                });
                
                // 잠시 강조 표시
                firstSentenceEl.classList.add('highlighted');
                setTimeout(() => {
                    firstSentenceEl.classList.remove('highlighted');
                }, 2000);
            }
            
            // 씬의 첫 번째 문장 재생
            if (currentPlayer && scene.sentences[0]) {
                const firstSentence = scene.sentences[0];
                const startTime = firstSentence.startTime || firstSentence.start_time || 0;
                
                currentPlayer.currentTime = startTime;
                console.log(`Jumped to scene "${scene.title}" at ${startTime}s`);
            }
        }
        
        // MP3 추출 기능들
        function extractChapter(chapterId, event) {
            event.stopPropagation();
            if (!currentMedia) return;
            
            console.log('Extracting chapter:', chapterId);
            updateExtractStatus('챕터 MP3 추출 중...');
            
            fetch(`/api/media/${currentMedia}/chapter/${chapterId}/extract-mp3`, {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    updateExtractStatus(`챕터 MP3 추출 완료: <a href="${data.download_url}" download>다운로드</a>`);
                } else {
                    updateExtractStatus('챕터 MP3 추출 실패: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Extract error:', error);
                updateExtractStatus('챕터 MP3 추출 중 오류 발생');
            });
        }
        
        function extractScene(sceneId, event) {
            event.stopPropagation();
            if (!currentMedia) return;
            
            console.log('Extracting scene:', sceneId);
            updateExtractStatus('씬 MP3 추출 중...');
            
            fetch(`/api/media/${currentMedia}/scene/${sceneId}/extract-mp3`, {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    updateExtractStatus(`씬 MP3 추출 완료: <a href="${data.download_url}" download>다운로드</a>`);
                } else {
                    updateExtractStatus('씬 MP3 추출 실패: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Extract error:', error);
                updateExtractStatus('씬 MP3 추출 중 오류 발생');
            });
        }
        
        function extractChapterMP4(chapterId, event) {
            event.stopPropagation();
            if (!currentMedia) return;
            
            console.log('Extracting chapter MP4:', chapterId);
            updateExtractStatus('챕터 MP4 추출 중...');
            
            fetch(`/api/media/${currentMedia}/chapter/${chapterId}/extract-mp4`, {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    updateExtractStatus(`챕터 MP4 추출 완료: <a href="${data.download_url}" download>다운로드</a>`);
                } else {
                    updateExtractStatus('챕터 MP4 추출 실패: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Extract error:', error);
                updateExtractStatus('챕터 MP4 추출 중 오류 발생');
            });
        }
        
        function extractSceneMP4(sceneId, event) {
            event.stopPropagation();
            if (!currentMedia) return;
            
            console.log('Extracting scene MP4:', sceneId);
            updateExtractStatus('씬 MP4 추출 중...');
            
            fetch(`/api/media/${currentMedia}/scene/${sceneId}/extract-mp4`, {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    updateExtractStatus(`씬 MP4 추출 완료: <a href="${data.download_url}" download>다운로드</a>`);
                } else {
                    updateExtractStatus('씬 MP4 추출 실패: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Extract error:', error);
                updateExtractStatus('씬 MP4 추출 중 오류 발생');
            });
        }
        
        function extractAllChapters() {
            if (!currentMedia) return;
            
            console.log('Extracting all chapters');
            updateExtractStatus('모든 챕터 MP3 추출 중...');
            
            fetch(`/api/media/${currentMedia}/extract-all-chapters`, {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    updateExtractStatus(`모든 챕터 MP3 추출 완료: <a href="${data.download_url}" download>ZIP 다운로드</a>`);
                } else {
                    updateExtractStatus('모든 챕터 MP3 추출 실패: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Extract error:', error);
                updateExtractStatus('모든 챕터 MP3 추출 중 오류 발생');
            });
        }
        
        function extractAllScenes() {
            if (!currentMedia) return;
            
            console.log('Extracting all scenes');
            updateExtractStatus('모든 씬 MP3 추출 중...');
            
            fetch(`/api/media/${currentMedia}/extract-all-scenes`, {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    updateExtractStatus(`모든 씬 MP3 추출 완료: <a href="${data.download_url}" download>ZIP 다운로드</a>`);
                } else {
                    updateExtractStatus('모든 씬 MP3 추출 실패: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Extract error:', error);
                updateExtractStatus('모든 씬 MP3 추출 중 오류 발생');
            });
        }
        
        function extractBookmarkedOnly() {
            if (!currentMedia) return;
            
            console.log('Extracting bookmarked sentences');
            updateExtractStatus('북마크 문장 MP3 추출 중...');
            
            fetch(`/api/media/${currentMedia}/extract-bookmarked`, {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    updateExtractStatus(`북마크 문장 MP3 추출 완료: <a href="${data.download_url}" download>ZIP 다운로드</a>`);
                } else {
                    updateExtractStatus('북마크 문장 MP3 추출 실패: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Extract error:', error);
                updateExtractStatus('북마크 문장 MP3 추출 중 오류 발생');
            });
        }
        
        // MP4 추출 함수들
        function extractAllMP4() {
            if (!currentMedia) return;
            
            console.log('Extracting all sentences as MP4');
            updateExtractStatusMP4('모든 문장 MP4 추출 중...');
            
            fetch(`/api/media/${currentMedia}/extract_all_mp4`, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        updateExtractStatusMP4(`✅ ${data.message || '모든 문장 MP4 추출 완료'}`);
                    } else {
                        updateExtractStatusMP4(`❌ ${data.error}`);
                    }
                })
                .catch(error => {
                    console.error('Extract all MP4 error:', error);
                    updateExtractStatusMP4('❌ MP4 추출 중 오류가 발생했습니다.');
                });
        }
        
        function extractAllChaptersMP4() {
            if (!currentMedia) return;
            
            console.log('Extracting all chapters as MP4');
            updateExtractStatusMP4('모든 챕터 MP4 추출 중...');
            
            // 각 챕터별로 순차 처리
            fetch(`/api/media/${currentMedia}/chapters`)
            .then(response => response.json())
            .then(chapters => {
                if (chapters.length === 0) {
                    updateExtractStatusMP4('추출할 챕터가 없습니다.');
                    return;
                }
                
                Promise.all(chapters.map(chapter => 
                    fetch(`/api/media/${currentMedia}/chapter/${chapter.id}/extract-mp4`, {
                        method: 'POST'
                    }).then(response => response.json())
                )).then(results => {
                    const successCount = results.filter(r => r.success).length;
                    updateExtractStatusMP4(`챕터 MP4 추출 완료: ${successCount}/${chapters.length}개`);
                }).catch(error => {
                    console.error('Extract error:', error);
                    updateExtractStatusMP4('챕터 MP4 추출 중 오류 발생');
                });
            })
            .catch(error => {
                console.error('Extract error:', error);
                updateExtractStatusMP4('챕터 MP4 추출 중 오류 발생');
            });
        }
        
        function extractAllScenesMP4() {
            if (!currentMedia) return;
            
            console.log('Extracting all scenes as MP4');
            updateExtractStatusMP4('모든 씬 MP4 추출 중...');
            
            // 각 씬별로 순차 처리 - 구현 필요시 추가
            updateExtractStatusMP4('씬 MP4 추출 기능 준비 중...');
        }
        
        function extractBookmarkedOnlyMP4() {
            if (!currentMedia) return;
            
            const englishChecked = document.getElementById('bookmarkSubtitleEnglish').checked;
            const koreanChecked = document.getElementById('bookmarkSubtitleKorean').checked;
            
            console.log('Extracting bookmarked sentences as MP4', {englishChecked, koreanChecked});
            updateExtractStatusMP4('북마크 문장 MP4 추출 중...');
            
            fetch(`/api/media/${currentMedia}/extract-bookmarked-mp4`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    subtitle_english: englishChecked,
                    subtitle_korean: koreanChecked
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    updateExtractStatusMP4(`북마크 문장 MP4 추출 완료: ${data.output_path}`);
                } else {
                    updateExtractStatusMP4('북마크 문장 MP4 추출 실패: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Extract error:', error);
                updateExtractStatusMP4('북마크 문장 MP4 추출 중 오류 발생');
            });
        }
        
        function extractAllSentencesMP4() {
            if (!currentMedia) return;
            
            const englishChecked = document.getElementById('subtitleEnglish').checked;
            const koreanChecked = document.getElementById('subtitleKorean').checked;
            
            console.log('Extracting all sentences as MP4', {englishChecked, koreanChecked});
            updateExtractStatusMP4('전체 문장 분할 MP4 추출 중...');
            
            fetch(`/api/media/${currentMedia}/extract-all-sentences-mp4`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    subtitle_english: englishChecked,
                    subtitle_korean: koreanChecked
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    updateExtractStatusMP4(`전체 문장 분할 MP4 추출 완료: ${data.output_path}`);
                } else {
                    updateExtractStatusMP4('전체 문장 분할 MP4 추출 실패: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Extract error:', error);
                updateExtractStatusMP4('전체 문장 분할 MP4 추출 중 오류 발생');
            });
        }
        
        function updateExtractStatusMP4(message, progress = null) {
            const statusEl = document.getElementById('extractStatusMP4');
            if (statusEl) {
                statusEl.innerHTML = message;
                
                // 진행률 바 표시
                if (progress !== null) {
                    const progressBar = `
                        <div style="width: 100%; background-color: #333; border-radius: 5px; margin-top: 5px;">
                            <div style="width: ${progress}%; background-color: #007acc; height: 5px; border-radius: 5px;"></div>
                        </div>
                    `;
                    statusEl.innerHTML += progressBar;
                }
            }
        }
        
        function updateExtractStatus(message, progress = null) {
            const statusEl = document.getElementById('extractStatus');
            if (statusEl) {
                statusEl.innerHTML = message;
                
                // 진행률 바 표시
                if (progress !== null) {
                    let progressBar = statusEl.querySelector('.progress-bar');
                    if (!progressBar && progress >= 0) {
                        progressBar = document.createElement('div');
                        progressBar.className = 'progress-bar';
                        const progressFill = document.createElement('div');
                        progressFill.className = 'progress-fill';
                        progressBar.appendChild(progressFill);
                        statusEl.appendChild(progressBar);
                    }
                    
                    if (progressBar) {
                        const progressFill = progressBar.querySelector('.progress-fill');
                        if (progressFill) {
                            progressFill.style.width = `${Math.min(100, Math.max(0, progress))}%`;
                        }
                        
                        // 완료시 진행률 바 제거
                        if (progress >= 100) {
                            setTimeout(() => {
                                if (progressBar) progressBar.remove();
                            }, 1000);
                        }
                    }
                }
            }
        }
        
        function simulateProgress(statusMessage, duration = 3000) {
            let progress = 0;
            const interval = 100;
            const increment = (100 / duration) * interval;
            
            const progressInterval = setInterval(() => {
                progress += increment;
                updateExtractStatus(statusMessage, progress);
                
                if (progress >= 100) {
                    clearInterval(progressInterval);
                }
            }, interval);
            
            return progressInterval;
        }
        
        // VAD 필터 기능
        let vadFilterData = null;
        
        function toggleVADFilter() {
            const vadFilter = document.getElementById('vadFilter');
            const vadDetails = document.getElementById('vadDetails');
            
            if (vadFilter.checked) {
                vadDetails.style.display = 'block';
                console.log('VAD filter enabled');
            } else {
                vadDetails.style.display = 'none';
                console.log('VAD filter disabled');
                vadFilterData = null;
                // 원본 문장 표시로 복원
                if (currentMedia) {
                    loadGroupedSentences(currentMedia);
                }
            }
        }
        
        function updateVADThreshold() {
            const threshold = document.getElementById('vadThreshold').value;
            document.getElementById('vadThresholdValue').textContent = threshold;
        }
        
        function applyVADFilter() {
            if (!currentMedia) return;
            
            const threshold = parseFloat(document.getElementById('vadThreshold').value);
            updateVADStatus('VAD 필터 분석 중...');
            
            fetch(`/api/media/${currentMedia}/vad-filter`, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({threshold: threshold})
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    vadFilterData = data;
                    updateVADStatus(`분석 완료: 음성 ${data.voice_sentences}개, 무음 ${data.silence_sentences}개`);
                    console.log('VAD filter applied:', data);
                    
                    // 문장 표시 업데이트 (VAD 결과 반영)
                    applyVADVisualization();
                } else {
                    updateVADStatus('VAD 필터 적용 실패: ' + data.error);
                }
            })
            .catch(error => {
                console.error('VAD filter error:', error);
                updateVADStatus('VAD 필터 적용 중 오류 발생');
            });
        }
        
        function createVADAudio() {
            if (!currentMedia) return;
            
            updateVADStatus('무음 제거 오디오 생성 중...');
            
            fetch(`/api/media/${currentMedia}/create-vad-audio`, {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    updateVADStatus(`무음 제거 오디오 생성 완료: <a href="${data.download_url}" download>다운로드</a>`);
                } else {
                    updateVADStatus('무음 제거 오디오 생성 실패: ' + data.error);
                }
            })
            .catch(error => {
                console.error('VAD audio creation error:', error);
                updateVADStatus('무음 제거 오디오 생성 중 오류 발생');
            });
        }
        
        function updateVADStatus(message) {
            const statusEl = document.getElementById('vadStatus');
            if (statusEl) {
                statusEl.innerHTML = message;
            }
        }
        
        // 번역 관련 함수들
        function checkTranslationStatus() {
            if (!currentMedia) return;
            
            fetch(`/api/media/${currentMedia}/translation-status`)
                .then(response => response.json())
                .then(data => {
                    const infoEl = document.getElementById('translationInfo');
                    const btnEl = document.getElementById('translateBtn');
                    
                    if (data.total === 0) {
                        infoEl.innerHTML = '문장이 없습니다.';
                        btnEl.disabled = true;
                        return;
                    }
                    
                    const percentage = Math.round((data.translated / data.total) * 100);
                    infoEl.innerHTML = `
                        <div>전체: ${data.total}개 문장</div>
                        <div>번역됨: ${data.translated}개 (${percentage}%)</div>
                        <div>미번역: ${data.untranslated}개</div>
                    `;
                    
                    if (data.untranslated === 0) {
                        btnEl.textContent = '✅ 번역 완료';
                        btnEl.disabled = true;
                    } else if (data.status === 'translating') {
                        btnEl.textContent = '🔄 번역 중...';
                        btnEl.disabled = true;
                        document.getElementById('translationStatus').style.display = 'block';
                        document.getElementById('translationStatus').innerHTML = data.current || '번역 진행 중...';
                    } else {
                        btnEl.textContent = '🔄 자동 번역 시작';
                        btnEl.disabled = false;
                    }
                })
                .catch(error => {
                    console.error('Translation status error:', error);
                });
        }
        
        function startTranslation() {
            if (!currentMedia) return;
            
            const btnEl = document.getElementById('translateBtn');
            const statusEl = document.getElementById('translationStatus');
            
            btnEl.disabled = true;
            btnEl.textContent = '🔄 번역 시작 중...';
            statusEl.style.display = 'block';
            statusEl.innerHTML = '번역을 시작하는 중입니다...';
            
            fetch(`/api/media/${currentMedia}/translate`, {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    statusEl.innerHTML = `✅ ${data.message}`;
                    
                    // 번역 진행 상태 모니터링
                    translationInterval = setInterval(checkTranslationProgress, 2000);
                    
                    // 문장 다시 로드
                    setTimeout(() => {
                        loadGroupedSentences(currentMedia);
                    }, 1000);
                } else {
                    statusEl.innerHTML = `❌ 번역 실패: ${data.error}`;
                    btnEl.disabled = false;
                    btnEl.textContent = '🔄 자동 번역 시작';
                }
            })
            .catch(error => {
                console.error('Translation error:', error);
                statusEl.innerHTML = '❌ 번역 중 오류가 발생했습니다.';
                btnEl.disabled = false;
                btnEl.textContent = '🔄 자동 번역 시작';
            });
        }
        
        function checkTranslationProgress() {
            if (!currentMedia) {
                clearInterval(translationInterval);
                return;
            }
            
            fetch(`/api/media/${currentMedia}/translation-status`)
                .then(response => response.json())
                .then(data => {
                    const statusEl = document.getElementById('translationStatus');
                    
                    if (data.status === 'translating' && data.current) {
                        statusEl.innerHTML = data.current;
                    } else if (data.untranslated === 0) {
                        clearInterval(translationInterval);
                        statusEl.innerHTML = '✅ 번역이 완료되었습니다!';
                        checkTranslationStatus();
                        
                        // 문장 다시 로드하여 번역 표시
                        loadGroupedSentences(currentMedia);
                    }
                })
                .catch(error => {
                    console.error('Progress check error:', error);
                    clearInterval(translationInterval);
                });
        }
        
        function applyVADVisualization() {
            if (!vadFilterData) return;
            
            // 문장 요소들에 VAD 결과 시각화
            document.querySelectorAll('.sentence-item').forEach(sentenceEl => {
                const index = parseInt(sentenceEl.dataset.index);
                const sentence = sentences[index];
                
                if (sentence && sentence.vad_ratio !== undefined) {
                    if (sentence.vad_filtered) {
                        // 음성 구간 - 강조 표시
                        sentenceEl.style.borderLeft = '3px solid #4CAF50';
                        sentenceEl.style.backgroundColor = 'rgba(76, 175, 80, 0.1)';
                    } else {
                        // 무음 구간 - 흐리게 표시
                        sentenceEl.style.borderLeft = '3px solid #757575';
                        sentenceEl.style.backgroundColor = 'rgba(117, 117, 117, 0.1)';
                        sentenceEl.style.opacity = '0.6';
                    }
                    
                    // VAD 비율 표시
                    const vadInfo = document.createElement('div');
                    vadInfo.className = 'vad-info';
                    vadInfo.style.fontSize = '0.7em';
                    vadInfo.style.color = sentence.vad_filtered ? '#4CAF50' : '#757575';
                    vadInfo.textContent = `음성: ${(sentence.vad_ratio * 100).toFixed(0)}%`;
                    sentenceEl.appendChild(vadInfo);
                }
            });
        }
        
        function toggleBookmark(index, event) {
            event.stopPropagation();
            if (!currentMedia) return;
            
            const sentence = sentences[index];
            console.log('toggleBookmark called:', index, sentence);
            
            if (!sentence || !sentence.id) {
                console.error('No sentence ID found:', sentence);
                return;
            }
            
            fetch(`/api/media/${currentMedia}/sentences/${sentence.id}/bookmark`, {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    sentences[index].bookmark = data.bookmark ? 1 : 0;
                    
                    // 북마크 버튼 업데이트
                    const sentenceEl = document.querySelector(`[data-index="${index}"]`);
                    if (sentenceEl) {
                        if (data.bookmark) {
                            sentenceEl.classList.add('bookmarked');
                        } else {
                            sentenceEl.classList.remove('bookmarked');
                        }
                    }
                    
                    updateBookmarkedList();
                }
            })
            .catch(error => {
                console.error('Bookmark toggle error:', error);
            });
        }
        
        function updateBookmarkedList() {
            const bookmarkedEl = document.getElementById('bookmarkedList');
            const bookmarked = sentences.filter(s => s.bookmark);
            
            if (bookmarked.length === 0) {
                bookmarkedEl.innerHTML = '<p style="color: #858585;">북마크된 문장이 없습니다.</p>';
            } else {
                bookmarkedEl.innerHTML = bookmarked.map(s => 
                    `<div class="bookmarked-item">${s.id}. ${s.english}</div>`
                ).join('');
            }
        }
        
        function repeatCurrent() {
            if (currentSentenceIndex >= 0) {
                playSentence(currentSentenceIndex);
            }
        }
        
        function playBookmarked() {
            const bookmarked = sentences.filter(s => s.bookmark);
            if (bookmarked.length > 0) {
                let index = 0;
                
                function playNext() {
                    if (index < bookmarked.length) {
                        const sentenceIndex = sentences.findIndex(s => s.id === bookmarked[index].id);
                        playSentence(sentenceIndex);
                        index++;
                        setTimeout(playNext, 3000); // 3초 간격
                    }
                }
                
                playNext();
            }
        }
        
        function extractMP3(index, event) {
            event.stopPropagation();
            const sentence = sentences[index];
            
            if (!currentMedia || !sentence.id) {
                const btn = event.target;
                btn.textContent = '❌ 오류';
                btn.style.background = '#ff4444';
                setTimeout(() => {
                    btn.textContent = 'MP3';
                    btn.style.background = '#0e639c';
                }, 2000);
                return;
            }
            
            // 버튼 상태 변경
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = '추출중...';
            btn.disabled = true;
            
            fetch(`/api/sentence/${currentMedia}/${sentence.id}/extract-mp3`, {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // 다운로드 링크 생성
                    const a = document.createElement('a');
                    a.href = data.download_url;
                    a.download = data.filename;
                    a.click();
                    
                    console.log(`MP3 추출 완료: ${data.filename}`);
                } else {
                    console.error('MP3 추출 실패:', data.error);
                }
            })
            .catch(error => {
                console.error('MP3 추출 오류:', error);
            })
            .finally(() => {
                // 버튼 상태 복원
                btn.textContent = originalText;
                btn.disabled = false;
            });
        }
        
        function extractMP4(index, event) {
            event.stopPropagation();
            const sentence = sentences[index];
            
            if (!currentMedia || !sentence.id) {
                const btn = event.target;
                btn.textContent = '❌ 오류';
                btn.style.background = '#ff4444';
                setTimeout(() => {
                    btn.textContent = 'MP4';
                    btn.style.background = '#2563eb';
                }, 2000);
                return;
            }
            
            // 버튼 상태 변경
            const btn = event.target;
            const originalText = btn.textContent;
            btn.textContent = '추출중...';
            btn.disabled = true;
            
            fetch(`/api/sentence/${currentMedia}/${sentence.id}/extract-mp4`, {
                method: 'POST'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    console.log(`MP4 추출 완료: ${data.output_path}`);
                    btn.textContent = '✅ 완료';
                    btn.style.background = '#4caf50';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '#2563eb';
                    }, 3000);
                } else {
                    console.error('MP4 추출 실패:', data.error);
                    btn.textContent = '❌ 실패';
                    btn.style.background = '#ff4444';
                    setTimeout(() => {
                        btn.textContent = originalText;
                        btn.style.background = '#2563eb';
                    }, 3000);
                }
            })
            .catch(error => {
                console.error('MP4 추출 오류:', error);
            })
            .finally(() => {
                // 버튼 상태 복원
                btn.textContent = originalText;
                btn.disabled = false;
            });
        }
        
        function exportBookmarks() {
            const bookmarked = sentences.filter(s => s.bookmark);
            if (bookmarked.length === 0) {
                // 버튼에 피드백 표시
                const btn = event.target;
                const originalText = btn.textContent;
                btn.textContent = '❌ 북마크 없음';
                btn.style.background = '#ff4444';
                setTimeout(() => {
                    btn.textContent = originalText;
                    btn.style.background = '#d79921';
                }, 2000);
                return;
            }
            
            const content = bookmarked.map(s => `${s.id}. ${s.english}\n${s.korean}`).join('\n\n');
            const blob = new Blob([content], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'bookmarked_sentences.txt';
            a.click();
            URL.revokeObjectURL(url);
        }
        
        let searchTimeout = null;
        
        function handleSearchInput(event) {
            const query = event.target.value.trim();
            const resultsEl = document.getElementById('searchResults');
            
            // 이전 타이머 취소
            if (searchTimeout) {
                clearTimeout(searchTimeout);
            }
            
            if (query.length < 3) {
                resultsEl.innerHTML = '';
                showAllSentences();
                return;
            }
            
            // 300ms 지연 후 검색 실행
            searchTimeout = setTimeout(() => {
                performSearch(query);
            }, 300);
        }
        
        function performSearch(query) {
            const resultsEl = document.getElementById('searchResults');
            
            if (!sentences || sentences.length === 0) {
                resultsEl.innerHTML = '검색할 문장이 없습니다.';
                return;
            }
            
            // 영어와 한국어에서 검색
            const matches = sentences.filter(sentence => {
                const englishMatch = sentence.english && sentence.english.toLowerCase().includes(query.toLowerCase());
                const koreanMatch = sentence.korean && sentence.korean.includes(query);
                return englishMatch || koreanMatch;
            });
            
            if (matches.length === 0) {
                resultsEl.innerHTML = `"${query}"에 대한 검색 결과가 없습니다.`;
                hideAllSentences();
                return;
            }
            
            resultsEl.innerHTML = `${matches.length}개 문장이 발견되었습니다.`;
            
            // 매칭된 문장만 표시
            highlightSearchResults(matches, query);
        }
        
        function highlightSearchResults(matches, query) {
            // 모든 문장 숨기기
            document.querySelectorAll('.sentence-item').forEach(item => {
                item.style.display = 'none';
            });
            
            // 매칭된 문장만 표시하고 하이라이트
            matches.forEach(match => {
                const sentenceEl = document.querySelector(`[data-sentence-id="${match.id}"]`);
                if (sentenceEl) {
                    sentenceEl.style.display = 'block';
                    
                    // 검색어 하이라이트
                    const englishEl = sentenceEl.querySelector('.sentence-text');
                    const koreanEl = sentenceEl.querySelector('.sentence-korean');
                    
                    if (englishEl) {
                        const highlightedEnglish = highlightText(match.english, query);
                        englishEl.innerHTML = highlightedEnglish;
                    }
                    
                    if (koreanEl && match.korean) {
                        const highlightedKorean = highlightText(match.korean, query);
                        koreanEl.innerHTML = highlightedKorean;
                    }
                    
                    // 부모 챕터/씬도 표시
                    let parent = sentenceEl.closest('.scene-section');
                    while (parent) {
                        parent.style.display = 'block';
                        const content = parent.querySelector('.scene-content, .chapter-content');
                        if (content) content.style.display = 'block';
                        parent = parent.closest('.chapter-section');
                    }
                }
            });
        }
        
        function highlightText(text, query) {
            if (!text || !query) return text;
            
            const regex = new RegExp(`(${query})`, 'gi');
            return text.replace(regex, '<mark style="background: #ffd700; color: #000;">$1</mark>');
        }
        
        function showAllSentences() {
            document.querySelectorAll('.sentence-item, .scene-section, .chapter-section').forEach(item => {
                item.style.display = 'block';
            });
            
            // 원본 텍스트 복원
            sentences.forEach(sentence => {
                const sentenceEl = document.querySelector(`[data-sentence-id="${sentence.id}"]`);
                if (sentenceEl) {
                    const englishEl = sentenceEl.querySelector('.sentence-text');
                    const koreanEl = sentenceEl.querySelector('.sentence-korean');
                    
                    if (englishEl) englishEl.innerHTML = sentence.english;
                    if (koreanEl) koreanEl.innerHTML = sentence.korean || '';
                }
            });
        }
        
        function hideAllSentences() {
            document.querySelectorAll('.sentence-item').forEach(item => {
                item.style.display = 'none';
            });
        }
        
        function deleteMedia(mediaId, event) {
            event.stopPropagation();
            
            if (!confirm('정말로 이 미디어를 삭제하시겠습니까? 모든 문장과 북마크가 삭제됩니다.')) {
                return;
            }
            
            fetch(`/api/media/${mediaId}`, {
                method: 'DELETE'
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // 현재 선택된 미디어인 경우 초기화
                    if (currentMedia === mediaId) {
                        currentMedia = null;
                        document.querySelector('.media-player').style.display = 'none';
                        document.getElementById('sentenceList').innerHTML = '';
                        document.getElementById('bookmarkedList').innerHTML = '<p style="color: #858585;">북마크된 문장이 없습니다.</p>';
                        document.getElementById('processingOptions').style.display = 'none';
                        document.getElementById('searchSection').style.display = 'none';
                                    document.getElementById('uploadSection').style.display = 'block';
                    }
                    
                    // 미디어 목록 새로고침
                    loadMediaList();
                    
                    console.log('Media deleted successfully');
                } else {
                    console.error('삭제 실패:', data.error);
                }
            })
            .catch(error => {
                console.error('Delete error:', error);
            });
        }
    </script>
    
    <!-- Video.js JavaScript -->
</body>
</html>